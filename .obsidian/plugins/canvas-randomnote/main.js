/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/crypt/crypt.js
var require_crypt = __commonJS({
  "node_modules/crypt/crypt.js"(exports, module2) {
    (function() {
      var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
        rotl: function(n, b) {
          return n << b | n >>> 32 - b;
        },
        rotr: function(n, b) {
          return n << 32 - b | n >>> b;
        },
        endian: function(n) {
          if (n.constructor == Number) {
            return crypt.rotl(n, 8) & 16711935 | crypt.rotl(n, 24) & 4278255360;
          }
          for (var i = 0; i < n.length; i++)
            n[i] = crypt.endian(n[i]);
          return n;
        },
        randomBytes: function(n) {
          for (var bytes = []; n > 0; n--)
            bytes.push(Math.floor(Math.random() * 256));
          return bytes;
        },
        bytesToWords: function(bytes) {
          for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
            words[b >>> 5] |= bytes[i] << 24 - b % 32;
          return words;
        },
        wordsToBytes: function(words) {
          for (var bytes = [], b = 0; b < words.length * 32; b += 8)
            bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
          return bytes;
        },
        bytesToHex: function(bytes) {
          for (var hex = [], i = 0; i < bytes.length; i++) {
            hex.push((bytes[i] >>> 4).toString(16));
            hex.push((bytes[i] & 15).toString(16));
          }
          return hex.join("");
        },
        hexToBytes: function(hex) {
          for (var bytes = [], c = 0; c < hex.length; c += 2)
            bytes.push(parseInt(hex.substr(c, 2), 16));
          return bytes;
        },
        bytesToBase64: function(bytes) {
          for (var base64 = [], i = 0; i < bytes.length; i += 3) {
            var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
            for (var j = 0; j < 4; j++)
              if (i * 8 + j * 6 <= bytes.length * 8)
                base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
              else
                base64.push("=");
          }
          return base64.join("");
        },
        base64ToBytes: function(base64) {
          base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
          for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
            if (imod4 == 0)
              continue;
            bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
          }
          return bytes;
        }
      };
      module2.exports = crypt;
    })();
  }
});

// node_modules/charenc/charenc.js
var require_charenc = __commonJS({
  "node_modules/charenc/charenc.js"(exports, module2) {
    var charenc = {
      utf8: {
        stringToBytes: function(str) {
          return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        bytesToString: function(bytes) {
          return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
      },
      bin: {
        stringToBytes: function(str) {
          for (var bytes = [], i = 0; i < str.length; i++)
            bytes.push(str.charCodeAt(i) & 255);
          return bytes;
        },
        bytesToString: function(bytes) {
          for (var str = [], i = 0; i < bytes.length; i++)
            str.push(String.fromCharCode(bytes[i]));
          return str.join("");
        }
      }
    };
    module2.exports = charenc;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module2) {
    module2.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/md5/md5.js
var require_md5 = __commonJS({
  "node_modules/md5/md5.js"(exports, module2) {
    (function() {
      var crypt = require_crypt(), utf8 = require_charenc().utf8, isBuffer = require_is_buffer(), bin = require_charenc().bin, md52 = function(message, options) {
        if (message.constructor == String)
          if (options && options.encoding === "binary")
            message = bin.stringToBytes(message);
          else
            message = utf8.stringToBytes(message);
        else if (isBuffer(message))
          message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message) && message.constructor !== Uint8Array)
          message = message.toString();
        var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        for (var i = 0; i < m.length; i++) {
          m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
        }
        m[l >>> 5] |= 128 << l % 32;
        m[(l + 64 >>> 9 << 4) + 14] = l;
        var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
        for (var i = 0; i < m.length; i += 16) {
          var aa = a, bb = b, cc = c, dd = d;
          a = FF(a, b, c, d, m[i + 0], 7, -680876936);
          d = FF(d, a, b, c, m[i + 1], 12, -389564586);
          c = FF(c, d, a, b, m[i + 2], 17, 606105819);
          b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
          a = FF(a, b, c, d, m[i + 4], 7, -176418897);
          d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
          c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
          b = FF(b, c, d, a, m[i + 7], 22, -45705983);
          a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
          d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
          c = FF(c, d, a, b, m[i + 10], 17, -42063);
          b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
          a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
          d = FF(d, a, b, c, m[i + 13], 12, -40341101);
          c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
          b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
          a = GG(a, b, c, d, m[i + 1], 5, -165796510);
          d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
          c = GG(c, d, a, b, m[i + 11], 14, 643717713);
          b = GG(b, c, d, a, m[i + 0], 20, -373897302);
          a = GG(a, b, c, d, m[i + 5], 5, -701558691);
          d = GG(d, a, b, c, m[i + 10], 9, 38016083);
          c = GG(c, d, a, b, m[i + 15], 14, -660478335);
          b = GG(b, c, d, a, m[i + 4], 20, -405537848);
          a = GG(a, b, c, d, m[i + 9], 5, 568446438);
          d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
          c = GG(c, d, a, b, m[i + 3], 14, -187363961);
          b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
          a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
          d = GG(d, a, b, c, m[i + 2], 9, -51403784);
          c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
          b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
          a = HH(a, b, c, d, m[i + 5], 4, -378558);
          d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
          c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
          b = HH(b, c, d, a, m[i + 14], 23, -35309556);
          a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
          d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
          c = HH(c, d, a, b, m[i + 7], 16, -155497632);
          b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
          a = HH(a, b, c, d, m[i + 13], 4, 681279174);
          d = HH(d, a, b, c, m[i + 0], 11, -358537222);
          c = HH(c, d, a, b, m[i + 3], 16, -722521979);
          b = HH(b, c, d, a, m[i + 6], 23, 76029189);
          a = HH(a, b, c, d, m[i + 9], 4, -640364487);
          d = HH(d, a, b, c, m[i + 12], 11, -421815835);
          c = HH(c, d, a, b, m[i + 15], 16, 530742520);
          b = HH(b, c, d, a, m[i + 2], 23, -995338651);
          a = II(a, b, c, d, m[i + 0], 6, -198630844);
          d = II(d, a, b, c, m[i + 7], 10, 1126891415);
          c = II(c, d, a, b, m[i + 14], 15, -1416354905);
          b = II(b, c, d, a, m[i + 5], 21, -57434055);
          a = II(a, b, c, d, m[i + 12], 6, 1700485571);
          d = II(d, a, b, c, m[i + 3], 10, -1894986606);
          c = II(c, d, a, b, m[i + 10], 15, -1051523);
          b = II(b, c, d, a, m[i + 1], 21, -2054922799);
          a = II(a, b, c, d, m[i + 8], 6, 1873313359);
          d = II(d, a, b, c, m[i + 15], 10, -30611744);
          c = II(c, d, a, b, m[i + 6], 15, -1560198380);
          b = II(b, c, d, a, m[i + 13], 21, 1309151649);
          a = II(a, b, c, d, m[i + 4], 6, -145523070);
          d = II(d, a, b, c, m[i + 11], 10, -1120210379);
          c = II(c, d, a, b, m[i + 2], 15, 718787259);
          b = II(b, c, d, a, m[i + 9], 21, -343485551);
          a = a + aa >>> 0;
          b = b + bb >>> 0;
          c = c + cc >>> 0;
          d = d + dd >>> 0;
        }
        return crypt.endian([a, b, c, d]);
      };
      md52._ff = function(a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md52._gg = function(a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md52._hh = function(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md52._ii = function(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md52._blocksize = 16;
      md52._digestsize = 16;
      module2.exports = function(message, options) {
        if (message === void 0 || message === null)
          throw new Error("Illegal argument " + message);
        var digestbytes = crypt.wordsToBytes(md52(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
      };
    })();
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvasRandomNotePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  noteWidth: "400",
  noteHeight: "500",
  noteMargin: "50",
  x: "0",
  y: "0",
  numNotes: "9",
  numNotesPerRow: "3"
};

// src/util.ts
function randomElements(arr, quantity) {
  const result = new Array(quantity);
  let len = arr.length;
  const taken = new Array(len);
  if (quantity > len)
    return arr;
  while (quantity--) {
    const x = Math.floor(Math.random() * len);
    result[quantity] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}
function buildGrid(numberElems, numberElemsPerRow, elemWidth, elemHeight, elemMargin, xAnchor, yAnchor) {
  const grid = [];
  let x = xAnchor;
  let y = yAnchor;
  for (let i = 0; i < numberElems; i++) {
    grid.push({ x, y });
    x += elemWidth + elemMargin;
    if ((i + 1) % numberElemsPerRow === 0) {
      x = xAnchor;
      y += elemHeight + elemMargin;
    }
  }
  return grid;
}

// main.ts
var import_md5 = __toESM(require_md5());

// src/InsertModal.ts
var import_obsidian = require("obsidian");
var InsertModal = class extends import_obsidian.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.confirmed = false;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Canvas RandomNote Settings" });
    const settings = this.plugin.settings;
    new import_obsidian.Setting(contentEl).setName("Number of Notes").setDesc("Number of notes to add to canvas").addText((text) => text.setValue(settings.numNotes).onChange(async (value) => {
      settings.numNotes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).setName("Notes per row").setDesc("Number of notes per row").addText((text) => text.setValue(settings.numNotesPerRow).onChange(async (value) => {
      settings.numNotesPerRow = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).setName("Note Width").addText((text) => text.setValue(settings.noteWidth).onChange(async (value) => {
      settings.noteWidth = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).setName("Note Height").addText((text) => text.setValue(settings.noteHeight).onChange(async (value) => {
      settings.noteHeight = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).setName("Note Margin").setDesc("Margin (horizontal and vertical) between notes").addText((text) => text.setValue(settings.noteMargin).onChange(async (value) => {
      settings.noteMargin = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).setName("X-anchor").setDesc("X-coordinate of top-left corner of first note").addText((text) => text.setValue(settings.x).onChange(async (value) => {
      settings.x = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).setName("Y-anchor").setDesc("Y-coordinate of top-left corner of first note").addText((text) => text.setValue(settings.y).onChange(async (value) => {
      settings.y = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Add Notes").setCta().onClick(() => {
      this.confirmed = true;
      this.close();
    }));
  }
};
var InsertModal_default = InsertModal;

// main.ts
var CanvasRandomNotePlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.activeFileIsCanvas = (file) => {
      return file.extension === "canvas";
    };
    this.getCanvasContents = async (file) => {
      const fileContents = await this.app.vault.read(file);
      if (!fileContents) {
        return this.handleEmptyCanvas();
      }
      const canvasData = JSON.parse(fileContents);
      return canvasData;
    };
    this.handleEmptyCanvas = () => {
      const data = {
        nodes: [],
        edges: []
      };
      return data;
    };
    this.handlegetRandomNotes = async (quantity) => {
      const markdownFiles = this.app.vault.getMarkdownFiles();
      if (!markdownFiles.length) {
        new import_obsidian2.Notice("No files available.", 5e3);
        return [];
      }
      if (markdownFiles.length < quantity) {
        new import_obsidian2.Notice("Not enough files available. Using all available options.", 5e3);
      }
      const notes = await this.getRandomNotes(markdownFiles, quantity);
      return notes;
    };
    this.handlegetRandomNotesFromSearch = async (quantity) => {
      var _a;
      const searchView = (_a = this.app.workspace.getLeavesOfType("search")[0]) == null ? void 0 : _a.view;
      if (!searchView) {
        new import_obsidian2.Notice("The core search plugin is not enabled", 3e3);
        return [];
      }
      const searchResults = searchView.dom.getFiles();
      if (!searchResults.length) {
        new import_obsidian2.Notice("No search results available", 3e3);
        return [];
      }
      if (searchResults.length < quantity) {
        new import_obsidian2.Notice("Not enough search results available. Using all available options.", 3e3);
      }
      const notes = await this.getRandomNotes(searchResults, quantity);
      return notes;
    };
    this.getRandomNotes = async (files, quantity) => {
      const markdownFiles = files.filter((file) => file.extension === "md");
      if (!markdownFiles.length) {
        new import_obsidian2.Notice("No files available.", 5e3);
        return [];
      }
      const notes = randomElements(markdownFiles, quantity);
      return notes;
    };
    this.buildFileNodeGrid = (notes, canvasData) => {
      const filenames = notes.map((note) => note.path);
      const { numNotesPerRow, noteWidth, noteHeight, noteMargin, x, y } = this.settings;
      const grid = buildGrid(notes.length, parseInt(numNotesPerRow), parseInt(noteWidth), parseInt(noteHeight), parseInt(noteMargin), parseInt(x), parseInt(y));
      const fileNodes = grid.map((node, index) => {
        const fileNode = {
          id: (0, import_md5.default)(filenames[index]),
          x: node.x,
          y: node.y,
          width: parseInt(noteWidth),
          height: parseInt(noteHeight),
          color: "",
          type: "file",
          file: `${filenames[index]}`
        };
        return fileNode;
      });
      canvasData.nodes = canvasData.nodes.concat(fileNodes);
      return canvasData;
    };
    this.writeCanvasFile = async (file, canvasData) => {
      const fileContents = JSON.stringify(canvasData);
      await this.app.vault.modify(file, fileContents);
    };
    this.awaitModal = async () => {
      return new Promise((resolve, reject) => {
        try {
          const modal = new InsertModal_default(this);
          modal.onClose = () => {
            resolve(modal.confirmed);
          };
          modal.open();
        } catch (e) {
          reject();
        }
      });
    };
    this.addNotesHandler = async (getNotesFn) => {
      try {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && this.activeFileIsCanvas(activeFile)) {
          let canvasContents = await this.getCanvasContents(activeFile);
          const confirmed = await this.awaitModal();
          if (!confirmed) {
            return;
          }
          const randomNotes = await getNotesFn(parseInt(this.settings.numNotes));
          const newContents = this.buildFileNodeGrid(randomNotes, canvasContents);
          await this.writeCanvasFile(activeFile, newContents);
        } else {
          new import_obsidian2.Notice("No active canvas file.", 5e3);
        }
      } catch (e) {
        console.error(e);
        new import_obsidian2.Notice("An unexpected error has occurred. It's possible the Obsidian app is out of sync with the canvas file contents. Wait a few moments before running commands.", 5e3);
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "canvas-randomnote-add-notes",
      name: "Add Notes to Canvas",
      callback: async () => {
        this.addNotesHandler(this.handlegetRandomNotes);
      }
    });
    this.addCommand({
      id: "canvas-randomnote-add-notes-from-search",
      name: "Add Notes to Canvas from Search",
      callback: async () => {
        this.addNotesHandler(this.handlegetRandomNotesFromSearch);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
