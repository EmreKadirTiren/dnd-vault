/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://github.com/motdotla/dotenv?sponsor=1",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs = require("fs");
    var path3 = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path3.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path3.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      let dotenvPath = path3.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      if (options) {
        if (options.path != null) {
          let envPath = options.path;
          if (Array.isArray(envPath)) {
            for (const filepath of options.path) {
              if (fs.existsSync(filepath)) {
                envPath = filepath;
                break;
              }
            }
          }
          dotenvPath = _resolveHome(envPath);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        } else {
          if (debug) {
            _debug("No encoding is specified. UTF-8 is used by default");
          }
        }
      }
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }));
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
        return { parsed };
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${dotenvPath} ${e.message}`);
        }
        return { error: e };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// node_modules/slug/slug.js
var require_slug = __commonJS({
  "node_modules/slug/slug.js"(exports, module2) {
    (function(root) {
      let base64;
      function getWholeCharAndI(str, i) {
        const code = str.charCodeAt(i);
        if (isNaN(code)) {
          throw new RangeError("Index " + i + ' out of range for string "' + str + '"; please open an issue at https://github.com/Trott/slug/issues/new');
        }
        if (code < 55296 || code > 57343) {
          return [str.charAt(i), i];
        }
        if (code >= 55296 && code <= 56319) {
          if (str.length <= i + 1) {
            return [" ", i];
          }
          const next = str.charCodeAt(i + 1);
          if (next < 56320 || next > 57343) {
            return [" ", i];
          }
          return [str.charAt(i) + str.charAt(i + 1), i + 1];
        }
        if (i === 0) {
          return [" ", i];
        }
        const prev = str.charCodeAt(i - 1);
        if (prev < 55296 || prev > 56319) {
          return [" ", i];
        }
        throw new Error('String "' + str + '" reaches code believed to be unreachable; please open an issue at https://github.com/Trott/slug/issues/new');
      }
      if (typeof window !== "undefined") {
        if (window.btoa) {
          base64 = function(input) {
            return btoa(unescape(encodeURIComponent(input)));
          };
        } else {
          base64 = function(input) {
            const str = unescape(encodeURIComponent(input + ""));
            let output = "";
            for (let block, charCode, idx = 0, map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; str.charAt(idx | 0) || (map = "=", idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
              charCode = str.charCodeAt(idx += 3 / 4);
              if (charCode > 255) {
                throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
              }
              block = block << 8 | charCode;
            }
            return output;
          };
        }
      } else {
        base64 = function(input) {
          return Buffer.from(input).toString("base64");
        };
      }
      function slug2(string, opts) {
        let result = slugify(string, opts);
        const fallback = opts && opts.fallback !== void 0 ? opts.fallback : slug2.defaults.fallback;
        if (fallback === true && result === "") {
          let input = "";
          for (let i = 0; i < string.length; i++) {
            const charAndI = getWholeCharAndI(string, i);
            i = charAndI[1];
            input += charAndI[0];
          }
          result = slugify(base64(input), opts);
        }
        return result;
      }
      const locales = {
        // http://www.eki.ee/wgrs/rom1_bg.pdf
        bg: { \u0419: "Y", \u0439: "y", X: "H", x: "h", \u0426: "Ts", \u0446: "ts", \u0429: "Sht", \u0449: "sht", \u042A: "A", \u044A: "a", \u042C: "Y", \u044C: "y" },
        // Need a reference URL for German, although this is pretty well-known.
        de: { \u00C4: "AE", \u00E4: "ae", \u00D6: "OE", \u00F6: "oe", \u00DC: "UE", \u00FC: "ue" },
        // Need a reference URL for Serbian.
        sr: { \u0111: "dj", \u0110: "DJ" },
        // https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/864314/ROMANIZATION_OF_UKRAINIAN.pdf
        uk: { \u0418: "Y", \u0438: "y", \u0419: "Y", \u0439: "y", \u0426: "Ts", \u0446: "ts", \u0425: "Kh", \u0445: "kh", \u0429: "Shch", \u0449: "shch", \u0413: "H", \u0433: "h" }
      };
      let defaultLocale = {};
      function slugify(string, opts) {
        if (typeof string !== "string") {
          throw new Error("slug() requires a string argument, received " + typeof string);
        }
        if (typeof opts === "string") {
          opts = { replacement: opts };
        }
        opts = opts ? Object.assign({}, opts) : {};
        opts.mode = opts.mode || slug2.defaults.mode;
        const defaults = slug2.defaults.modes[opts.mode];
        const keys = ["replacement", "multicharmap", "charmap", "remove", "lower", "trim"];
        for (let key, i = 0, l = keys.length; i < l; i++) {
          key = keys[i];
          opts[key] = key in opts ? opts[key] : defaults[key];
        }
        const localeMap = locales[opts.locale] || defaultLocale;
        let lengths = [];
        for (const key in opts.multicharmap) {
          if (!Object.prototype.hasOwnProperty.call(opts.multicharmap, key)) {
            continue;
          }
          const len = key.length;
          if (lengths.indexOf(len) === -1) {
            lengths.push(len);
          }
        }
        lengths = lengths.sort(function(a, b) {
          return b - a;
        });
        const disallowedChars = opts.mode === "rfc3986" ? /[^\w\s\-.~]/ : /[^A-Za-z0-9\s]/;
        let result = "";
        for (let char, i = 0, l = string.length; i < l; i++) {
          char = string[i];
          let matchedMultichar = false;
          for (let j = 0; j < lengths.length; j++) {
            const len = lengths[j];
            const str = string.substr(i, len);
            if (opts.multicharmap[str]) {
              i += len - 1;
              char = opts.multicharmap[str];
              matchedMultichar = true;
              break;
            }
          }
          if (!matchedMultichar) {
            if (localeMap[char]) {
              char = localeMap[char];
            } else if (opts.charmap[char]) {
              char = opts.charmap[char].replace(opts.replacement, " ");
            } else if (char.includes(opts.replacement)) {
              char = char.replace(opts.replacement, " ");
            } else {
              char = char.replace(disallowedChars, "");
            }
          }
          result += char;
        }
        if (opts.remove) {
          result = result.replace(opts.remove, "");
        }
        if (opts.trim) {
          result = result.trim();
        }
        result = result.replace(/\s+/g, opts.replacement);
        if (opts.lower) {
          result = result.toLowerCase();
        }
        return result;
      }
      const initialMulticharmap = {
        // multibyte devanagari characters (hindi, sanskrit, etc.)
        \u092B\u093C: "Fi",
        \u0917\u093C: "Ghi",
        \u0916\u093C: "Khi",
        \u0915\u093C: "Qi",
        \u0921\u093C: "ugDha",
        \u0922\u093C: "ugDhha",
        \u092F\u093C: "Yi",
        \u091C\u093C: "Za",
        // hebrew
        // Refs: http://www.eki.ee/wgrs/rom1_he.pdf
        // Refs: https://en.wikipedia.org/wiki/Niqqud
        \u05D1\u05B4\u05D9: "i",
        \u05D1\u05B5: "e",
        \u05D1\u05B5\u05D9: "e",
        \u05D1\u05B6: "e",
        \u05D1\u05B7: "a",
        \u05D1\u05B8: "a",
        \u05D1\u05B9: "o",
        \u05D5\u05B9: "o",
        \u05D1\u05BB: "u",
        \u05D5\u05BC: "u",
        \u05D1\u05BC: "b",
        \u05DB\u05BC: "k",
        \u05DA\u05BC: "k",
        \u05E4\u05BC: "p",
        \u05E9\u05C1: "sh",
        \u05E9\u05C2: "s",
        \u05D1\u05B0: "e",
        \u05D7\u05B1: "e",
        \u05D7\u05B2: "a",
        \u05D7\u05B3: "o",
        \u05D1\u05B4: "i"
      };
      const initialCharmap = {
        // latin
        \u00C0: "A",
        \u00C1: "A",
        \u00C2: "A",
        \u00C3: "A",
        \u00C4: "A",
        \u00C5: "A",
        \u00C6: "AE",
        \u00C7: "C",
        \u00C8: "E",
        \u00C9: "E",
        \u00CA: "E",
        \u00CB: "E",
        \u00CC: "I",
        \u00CD: "I",
        \u00CE: "I",
        \u00CF: "I",
        \u00D0: "D",
        \u00D1: "N",
        \u00D2: "O",
        \u00D3: "O",
        \u00D4: "O",
        \u00D5: "O",
        \u00D6: "O",
        \u0150: "O",
        \u00D8: "O",
        \u014C: "O",
        \u00D9: "U",
        \u00DA: "U",
        \u00DB: "U",
        \u00DC: "U",
        \u0170: "U",
        \u00DD: "Y",
        \u00DE: "TH",
        \u00DF: "ss",
        \u00E0: "a",
        \u00E1: "a",
        \u00E2: "a",
        \u00E3: "a",
        \u00E4: "a",
        \u00E5: "a",
        \u00E6: "ae",
        \u00E7: "c",
        \u00E8: "e",
        \u00E9: "e",
        \u00EA: "e",
        \u00EB: "e",
        \u00EC: "i",
        \u00ED: "i",
        \u00EE: "i",
        \u00EF: "i",
        \u00F0: "d",
        \u00F1: "n",
        \u00F2: "o",
        \u00F3: "o",
        \u00F4: "o",
        \u00F5: "o",
        \u00F6: "o",
        \u0151: "o",
        \u00F8: "o",
        \u014D: "o",
        \u0152: "OE",
        \u0153: "oe",
        \u00F9: "u",
        \u00FA: "u",
        \u00FB: "u",
        \u00FC: "u",
        \u0171: "u",
        \u00FD: "y",
        \u00FE: "th",
        \u00FF: "y",
        "\u1E9E": "SS",
        // greek
        \u03B1: "a",
        \u03B2: "b",
        \u03B3: "g",
        \u03B4: "d",
        \u03B5: "e",
        \u03B6: "z",
        \u03B7: "h",
        \u03B8: "th",
        \u03B9: "i",
        \u03BA: "k",
        \u03BB: "l",
        \u03BC: "m",
        \u03BD: "n",
        \u03BE: "3",
        \u03BF: "o",
        \u03C0: "p",
        \u03C1: "r",
        \u03C3: "s",
        \u03C4: "t",
        \u03C5: "y",
        \u03C6: "f",
        \u03C7: "x",
        \u03C8: "ps",
        \u03C9: "w",
        \u03AC: "a",
        \u03AD: "e",
        \u03AF: "i",
        \u03CC: "o",
        \u03CD: "y",
        \u03AE: "h",
        \u03CE: "w",
        \u03C2: "s",
        \u03CA: "i",
        \u03B0: "y",
        \u03CB: "y",
        \u0390: "i",
        \u0391: "A",
        \u0392: "B",
        \u0393: "G",
        \u0394: "D",
        \u0395: "E",
        \u0396: "Z",
        \u0397: "H",
        \u0398: "Th",
        \u0399: "I",
        \u039A: "K",
        \u039B: "L",
        \u039C: "M",
        \u039D: "N",
        \u039E: "3",
        \u039F: "O",
        \u03A0: "P",
        \u03A1: "R",
        \u03A3: "S",
        \u03A4: "T",
        \u03A5: "Y",
        \u03A6: "F",
        \u03A7: "X",
        \u03A8: "PS",
        \u03A9: "W",
        \u0386: "A",
        \u0388: "E",
        \u038A: "I",
        \u038C: "O",
        \u038E: "Y",
        \u0389: "H",
        \u038F: "W",
        \u03AA: "I",
        \u03AB: "Y",
        // turkish
        \u015F: "s",
        \u015E: "S",
        \u0131: "i",
        \u0130: "I",
        \u011F: "g",
        \u011E: "G",
        // russian
        \u0430: "a",
        \u0431: "b",
        \u0432: "v",
        \u0433: "g",
        \u0434: "d",
        \u0435: "e",
        \u0451: "yo",
        \u0436: "zh",
        \u0437: "z",
        \u0438: "i",
        \u0439: "j",
        \u043A: "k",
        \u043B: "l",
        \u043C: "m",
        \u043D: "n",
        \u043E: "o",
        \u043F: "p",
        \u0440: "r",
        \u0441: "s",
        \u0442: "t",
        \u0443: "u",
        \u0444: "f",
        \u0445: "h",
        \u0446: "c",
        \u0447: "ch",
        \u0448: "sh",
        \u0449: "sh",
        \u044A: "u",
        \u044B: "y",
        \u044C: "",
        \u044D: "e",
        \u044E: "yu",
        \u044F: "ya",
        \u0410: "A",
        \u0411: "B",
        \u0412: "V",
        \u0413: "G",
        \u0414: "D",
        \u0415: "E",
        \u0401: "Yo",
        \u0416: "Zh",
        \u0417: "Z",
        \u0418: "I",
        \u0419: "J",
        \u041A: "K",
        \u041B: "L",
        \u041C: "M",
        \u041D: "N",
        \u041E: "O",
        \u041F: "P",
        \u0420: "R",
        \u0421: "S",
        \u0422: "T",
        \u0423: "U",
        \u0424: "F",
        \u0425: "H",
        \u0426: "C",
        \u0427: "Ch",
        \u0428: "Sh",
        \u0429: "Sh",
        \u042A: "U",
        \u042B: "Y",
        \u042C: "",
        \u042D: "E",
        \u042E: "Yu",
        \u042F: "Ya",
        // ukranian
        \u0404: "Ye",
        \u0406: "I",
        \u0407: "Yi",
        \u0490: "G",
        \u0454: "ye",
        \u0456: "i",
        \u0457: "yi",
        \u0491: "g",
        // czech
        \u010D: "c",
        \u010F: "d",
        \u011B: "e",
        \u0148: "n",
        \u0159: "r",
        \u0161: "s",
        \u0165: "t",
        \u016F: "u",
        \u017E: "z",
        \u010C: "C",
        \u010E: "D",
        \u011A: "E",
        \u0147: "N",
        \u0158: "R",
        \u0160: "S",
        \u0164: "T",
        \u016E: "U",
        \u017D: "Z",
        // slovak
        \u013E: "l",
        \u013A: "l",
        \u0155: "r",
        \u013D: "L",
        \u0139: "L",
        \u0154: "R",
        // polish
        \u0105: "a",
        \u0107: "c",
        \u0119: "e",
        \u0142: "l",
        \u0144: "n",
        \u015B: "s",
        \u017A: "z",
        \u017C: "z",
        \u0104: "A",
        \u0106: "C",
        \u0118: "E",
        \u0141: "L",
        \u0143: "N",
        \u015A: "S",
        \u0179: "Z",
        \u017B: "Z",
        // latvian
        \u0101: "a",
        \u0113: "e",
        \u0123: "g",
        \u012B: "i",
        \u0137: "k",
        \u013C: "l",
        \u0146: "n",
        \u016B: "u",
        \u0100: "A",
        \u0112: "E",
        \u0122: "G",
        \u012A: "I",
        \u0136: "K",
        \u013B: "L",
        \u0145: "N",
        \u016A: "U",
        // arabic
        \u0623: "a",
        \u0625: "i",
        \u0628: "b",
        \u062A: "t",
        \u062B: "th",
        \u062C: "g",
        \u062D: "h",
        \u062E: "kh",
        \u062F: "d",
        \u0630: "th",
        \u0631: "r",
        \u0632: "z",
        \u0633: "s",
        \u0634: "sh",
        \u0635: "s",
        \u0636: "d",
        \u0637: "t",
        \u0638: "th",
        \u0639: "aa",
        \u063A: "gh",
        \u0641: "f",
        \u0642: "k",
        \u0643: "k",
        \u0644: "l",
        \u0645: "m",
        \u0646: "n",
        \u0647: "h",
        \u0648: "o",
        \u064A: "y",
        \u0621: "aa",
        \u0629: "a",
        // farsi
        \u0622: "a",
        \u0627: "a",
        \u067E: "p",
        \u0698: "zh",
        \u06AF: "g",
        \u0686: "ch",
        \u06A9: "k",
        \u06CC: "i",
        // lithuanian
        \u0117: "e",
        \u012F: "i",
        \u0173: "u",
        \u0116: "E",
        \u012E: "I",
        \u0172: "U",
        // romanian
        \u021B: "t",
        \u021A: "T",
        \u0163: "t",
        \u0162: "T",
        \u0219: "s",
        \u0218: "S",
        \u0103: "a",
        \u0102: "A",
        // vietnamese
        \u1EA0: "A",
        \u1EA2: "A",
        \u1EA6: "A",
        \u1EA4: "A",
        \u1EAC: "A",
        \u1EA8: "A",
        \u1EAA: "A",
        \u1EB0: "A",
        \u1EAE: "A",
        \u1EB6: "A",
        \u1EB2: "A",
        \u1EB4: "A",
        \u1EB8: "E",
        \u1EBA: "E",
        \u1EBC: "E",
        \u1EC0: "E",
        \u1EBE: "E",
        \u1EC6: "E",
        \u1EC2: "E",
        \u1EC4: "E",
        \u1ECA: "I",
        \u1EC8: "I",
        \u0128: "I",
        \u1ECC: "O",
        \u1ECE: "O",
        \u1ED2: "O",
        \u1ED0: "O",
        \u1ED8: "O",
        \u1ED4: "O",
        \u1ED6: "O",
        \u01A0: "O",
        \u1EDC: "O",
        \u1EDA: "O",
        \u1EE2: "O",
        \u1EDE: "O",
        \u1EE0: "O",
        \u1EE4: "U",
        \u1EE6: "U",
        \u0168: "U",
        \u01AF: "U",
        \u1EEA: "U",
        \u1EE8: "U",
        \u1EF0: "U",
        \u1EEC: "U",
        \u1EEE: "U",
        \u1EF2: "Y",
        \u1EF4: "Y",
        \u1EF6: "Y",
        \u1EF8: "Y",
        \u0110: "D",
        \u1EA1: "a",
        \u1EA3: "a",
        \u1EA7: "a",
        \u1EA5: "a",
        \u1EAD: "a",
        \u1EA9: "a",
        \u1EAB: "a",
        \u1EB1: "a",
        \u1EAF: "a",
        \u1EB7: "a",
        \u1EB3: "a",
        \u1EB5: "a",
        \u1EB9: "e",
        \u1EBB: "e",
        \u1EBD: "e",
        \u1EC1: "e",
        \u1EBF: "e",
        \u1EC7: "e",
        \u1EC3: "e",
        \u1EC5: "e",
        \u1ECB: "i",
        \u1EC9: "i",
        \u0129: "i",
        \u1ECD: "o",
        \u1ECF: "o",
        \u1ED3: "o",
        \u1ED1: "o",
        \u1ED9: "o",
        \u1ED5: "o",
        \u1ED7: "o",
        \u01A1: "o",
        \u1EDD: "o",
        \u1EDB: "o",
        \u1EE3: "o",
        \u1EDF: "o",
        \u1EE1: "o",
        \u1EE5: "u",
        \u1EE7: "u",
        \u0169: "u",
        \u01B0: "u",
        \u1EEB: "u",
        \u1EE9: "u",
        \u1EF1: "u",
        \u1EED: "u",
        \u1EEF: "u",
        \u1EF3: "y",
        \u1EF5: "y",
        \u1EF7: "y",
        \u1EF9: "y",
        \u0111: "d",
        // kazakh
        \u04D8: "AE",
        \u04D9: "ae",
        \u0492: "GH",
        \u0493: "gh",
        \u049A: "KH",
        \u049B: "kh",
        \u04A2: "NG",
        \u04A3: "ng",
        \u04AE: "UE",
        \u04AF: "ue",
        \u04B0: "U",
        \u04B1: "u",
        \u04BA: "H",
        \u04BB: "h",
        \u04E8: "OE",
        \u04E9: "oe",
        // serbian
        \u0452: "dj",
        \u0458: "j",
        \u0459: "lj",
        \u045A: "nj",
        \u045B: "c",
        \u045F: "dz",
        \u0402: "Dj",
        \u0408: "j",
        \u0409: "Lj",
        \u040A: "Nj",
        \u040B: "C",
        \u040F: "Dz",
        \u01CC: "nj",
        \u01C9: "lj",
        \u01CB: "NJ",
        \u01C8: "LJ",
        // hindi
        \u0905: "a",
        \u0906: "aa",
        \u090F: "e",
        \u0908: "ii",
        \u090D: "ei",
        \u090E: "ae",
        \u0910: "ai",
        \u0907: "i",
        \u0913: "o",
        \u0911: "oi",
        \u0912: "oii",
        \u090A: "uu",
        \u0914: "ou",
        \u0909: "u",
        \u092C: "B",
        \u092D: "Bha",
        \u091A: "Ca",
        \u091B: "Chha",
        \u0921: "Da",
        \u0922: "Dha",
        \u092B: "Fa",
        \u0917: "Ga",
        \u0918: "Gha",
        \u0917\u093C: "Ghi",
        \u0939: "Ha",
        \u091C: "Ja",
        \u091D: "Jha",
        \u0915: "Ka",
        \u0916: "Kha",
        \u0916\u093C: "Khi",
        \u0932: "L",
        \u0933: "Li",
        \u090C: "Li",
        \u0934: "Lii",
        \u0961: "Lii",
        \u092E: "Ma",
        \u0928: "Na",
        \u0919: "Na",
        \u091E: "Nia",
        \u0923: "Nae",
        \u0929: "Ni",
        \u0950: "oms",
        \u092A: "Pa",
        \u0915\u093C: "Qi",
        \u0930: "Ra",
        \u090B: "Ri",
        \u0960: "Ri",
        \u0931: "Ri",
        \u0938: "Sa",
        \u0936: "Sha",
        \u0937: "Shha",
        \u091F: "Ta",
        \u0924: "Ta",
        \u0920: "Tha",
        \u0926: "Tha",
        \u0925: "Tha",
        \u0927: "Thha",
        \u0921\u093C: "ugDha",
        \u0922\u093C: "ugDhha",
        \u0935: "Va",
        \u092F: "Ya",
        \u092F\u093C: "Yi",
        \u091C\u093C: "Za",
        // azerbaijani
        \u0259: "e",
        \u018F: "E",
        // georgian
        \u10D0: "a",
        \u10D1: "b",
        \u10D2: "g",
        \u10D3: "d",
        \u10D4: "e",
        \u10D5: "v",
        \u10D6: "z",
        \u10D7: "t",
        \u10D8: "i",
        \u10D9: "k",
        \u10DA: "l",
        \u10DB: "m",
        \u10DC: "n",
        \u10DD: "o",
        \u10DE: "p",
        \u10DF: "zh",
        \u10E0: "r",
        \u10E1: "s",
        \u10E2: "t",
        \u10E3: "u",
        \u10E4: "p",
        \u10E5: "k",
        \u10E6: "gh",
        \u10E7: "q",
        \u10E8: "sh",
        \u10E9: "ch",
        \u10EA: "ts",
        \u10EB: "dz",
        \u10EC: "ts",
        \u10ED: "ch",
        \u10EE: "kh",
        \u10EF: "j",
        \u10F0: "h",
        // hebrew
        \u05D1: "v",
        \u05D2\u05BC: "g",
        \u05D2: "g",
        \u05D3: "d",
        \u05D3\u05BC: "d",
        \u05D4: "h",
        \u05D5: "v",
        \u05D6: "z",
        \u05D7: "h",
        \u05D8: "t",
        \u05D9: "y",
        \u05DB: "kh",
        \u05DA: "kh",
        \u05DC: "l",
        \u05DE: "m",
        \u05DD: "m",
        \u05E0: "n",
        \u05DF: "n",
        \u05E1: "s",
        \u05E4: "f",
        \u05E3: "f",
        \u05E5: "ts",
        \u05E6: "ts",
        \u05E7: "k",
        \u05E8: "r",
        \u05EA\u05BC: "t",
        \u05EA: "t"
      };
      slug2.charmap = Object.assign({}, initialCharmap);
      slug2.multicharmap = Object.assign({}, initialMulticharmap);
      slug2.defaults = {
        charmap: slug2.charmap,
        mode: "pretty",
        modes: {
          rfc3986: {
            replacement: "-",
            remove: null,
            lower: true,
            charmap: slug2.charmap,
            multicharmap: slug2.multicharmap,
            trim: true
          },
          pretty: {
            replacement: "-",
            remove: null,
            lower: true,
            charmap: slug2.charmap,
            multicharmap: slug2.multicharmap,
            trim: true
          }
        },
        multicharmap: slug2.multicharmap,
        fallback: true
      };
      slug2.reset = function() {
        slug2.defaults.modes.rfc3986.charmap = slug2.defaults.modes.pretty.charmap = slug2.charmap = slug2.defaults.charmap = Object.assign({}, initialCharmap);
        slug2.defaults.modes.rfc3986.multicharmap = slug2.defaults.modes.pretty.multicharmap = slug2.multicharmap = slug2.defaults.multicharmap = Object.assign({}, initialMulticharmap);
        defaultLocale = "";
      };
      slug2.extend = function(customMap) {
        const keys = Object.keys(customMap);
        const multi = {};
        const single = {};
        for (let i = 0; i < keys.length; i++) {
          if (keys[i].length > 1) {
            multi[keys[i]] = customMap[keys[i]];
          } else {
            single[keys[i]] = customMap[keys[i]];
          }
        }
        Object.assign(slug2.charmap, single);
        Object.assign(slug2.multicharmap, multi);
      };
      slug2.setLocale = function(locale) {
        defaultLocale = locales[locale] || {};
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = slug2;
      } else {
        root.slug = slug2;
      }
    })(exports);
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QuickPluginSwitcher
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/main_modal.ts
var import_obsidian8 = require("obsidian");

// src/utils.ts
function isEnabled(modal, id) {
  return modal.app.plugins.enabledPlugins.has(id);
}
function removeItem(arr, value) {
  const index = arr.indexOf(value);
  if (index > -1) {
    arr.splice(index, 1);
  }
  return arr;
}
function formatNumber(num, precision = 3) {
  const map = [
    { suffix: "T", threshold: 1e12 },
    { suffix: "B", threshold: 1e9 },
    { suffix: "M", threshold: 1e6 },
    { suffix: "K", threshold: 1e3 },
    { suffix: "", threshold: 1 }
  ];
  const found = map.find((x) => Math.abs(num) >= x.threshold);
  if (found) {
    const value = num / found.threshold;
    const formatted = (found.suffix === "" ? value : value.toFixed(precision)) + found.suffix;
    return formatted;
  }
  return num.toString();
}
function calculateTimeElapsed(datePasted) {
  const delta = Math.abs(new Date().getTime() - datePasted.getTime()) / 1e3;
  const years = Math.floor(delta / (86400 * 365));
  if (years >= 2) {
    return `${years} years ago`;
  } else if (years === 1) {
    return "1 year ago";
  }
  const months = Math.floor(delta / (86400 * 30));
  if (months >= 2) {
    return `${months} months ago`;
  } else if (months === 1) {
    return "1 month ago";
  }
  const days = Math.floor(delta / 86400);
  if (days >= 2) {
    return `${days} days ago`;
  } else if (days === 1) {
    return "1 day ago";
  }
  const hours = Math.floor(delta / 3600) % 24;
  if (hours >= 2) {
    return `${hours} hours ago`;
  } else if (hours === 1) {
    return "1 hour ago";
  }
  const minutes = Math.floor(delta / 60) % 60;
  if (minutes >= 2) {
    return `${minutes} minutes ago`;
  } else if (minutes === 1) {
    return "1 minute ago";
  }
  return "seconds ago";
}
function hasKeyStartingWith(obj, prefix) {
  for (const key in obj) {
    if (key.startsWith(prefix)) {
      return true;
    }
  }
  return false;
}
function getSelectedContent() {
  const selection = window.getSelection();
  return selection == null ? void 0 : selection.toString();
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const length = binaryString.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

// src/secondary_modals.ts
var import_obsidian6 = require("obsidian");

// src/community-plugins_modal.ts
var import_fs = require("fs");
var import_obsidian5 = require("obsidian");

// src/modal_utils.ts
var import_obsidian2 = require("obsidian");

// src/types/variables.ts
var COMMPLUGINS = "https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-plugins.json";
var COMMPLUGINSTATS = "https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-plugin-stats.json";
var Filters = {
  all: "all",
  enabled: "enabled",
  disabled: "disabled",
  enabledFirst: "enabledFirst",
  mostSwitched: "mostSwitched",
  byGroup: "byGroup",
  hidden: "hidden"
};
var CommFilters = {
  all: "all",
  notInstalled: "notInstalled",
  installed: "installed",
  byGroup: "byGroup",
  hidden: "hidden",
  hasNote: "hasNote"
};
var TargetPlatform = /* @__PURE__ */ ((TargetPlatform2) => {
  TargetPlatform2[TargetPlatform2["Desktop"] = 0] = "Desktop";
  TargetPlatform2[TargetPlatform2["Mobile"] = 1] = "Mobile";
  TargetPlatform2[TargetPlatform2["Both"] = 2] = "Both";
  return TargetPlatform2;
})(TargetPlatform || {});
var SortBy = {
  Downloads: "by downloads",
  Alpha: "by alphanum",
  Updated: "by (recent) update",
  Released: "by (recent) release"
};
var Groups = {
  SelectGroup: "All"
};
var GroupsComm = {
  SelectGroup: "All"
};
var DEFAULT_SETTINGS = {
  lastFetchExe: 0,
  savedVersion: "0.0.0",
  installed: {},
  wasEnabled: [],
  sortBy: "Downloads",
  filters: "All",
  selectedGroup: "SelectGroup",
  search: "",
  numberOfGroups: 4,
  groups: {},
  showHotKeys: true,
  // commnunity plugins
  pluginStats: {},
  plugins: [],
  commPlugins: {},
  filtersComm: "All",
  selectedGroupComm: "SelectGroup",
  numberOfGroupsComm: 4,
  groupsComm: {},
  byAuthor: false,
  invertFiltersComm: false,
  commPluginsNotesFolder: "",
  keepDropDownValues: true
};

// src/groups.ts
var import_obsidian = require("obsidian");
var byGroupDropdowns = (modal, contentEl) => {
  const { plugin } = modal;
  const { settings } = plugin;
  if (modal instanceof QPSModal && settings.filters === Filters.byGroup) {
    getDropdownOptions(Groups, plugin.lengthAll);
  } else if (modal instanceof CPModal && settings.filtersComm === CommFilters.byGroup) {
    getDropdownOptions(GroupsComm, Object.keys(settings.commPlugins).length);
  }
  function getDropdownOptions(groups, length) {
    const dropdownOptions = {};
    for (const groupKey in groups) {
      const groupIndex = getIndexFromSelectedGroup(groupKey);
      if (groupKey === "SelectGroup") {
        dropdownOptions[groupKey] = groups[groupKey] + `(${length})`;
      } else if (!groupIsEmpty(groupIndex, modal)) {
        dropdownOptions[groupKey] = getEmojiForGroup(groupIndex).emoji + groups[groupKey];
      }
    }
    new import_obsidian.DropdownComponent(contentEl).addOptions(dropdownOptions).setValue(settings.selectedGroup).onChange(async (value) => {
      settings.selectedGroup = value;
      await reOpenModal(modal);
    });
  }
};
var addDelayToGroup = (modal, groupNumber, span, inGroup) => {
  var _a;
  const { plugin } = modal;
  const { settings } = plugin;
  const currentValue = (((_a = settings.groups[groupNumber]) == null ? void 0 : _a.time) || 0).toString();
  const input = createInput(span, currentValue);
  if (!input)
    return;
  input.onblur = async () => {
    await setDelay(input, settings, groupNumber, span, modal);
  };
  input.onkeydown = async (event) => {
    if (event.key === "Enter") {
      await setDelay(input, settings, groupNumber, span, modal);
    }
  };
  const setDelay = async (input2, settings2, groupNumber2, span2, modal2) => {
    const value = parseInt(input2.value) || 0;
    settings2.groups[groupNumber2].time = value;
    span2.textContent = `${value}`;
    if (inGroup.length) {
      await applyGroupDelay(inGroup, groupNumber2, modal2);
    }
    await reOpenModal(modal2);
  };
};
var applyGroupDelay = async (inGroup, groupNumber, modal) => {
  var _a;
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed } = settings;
  for (const id of inGroup) {
    installed[id].time = (_a = settings.groups[groupNumber]) == null ? void 0 : _a.time;
    const condition2 = !!installed[id].time;
    installed[id].delayed = condition2;
    settings.groups[groupNumber].applied = condition2;
    if (installed[id].enabled) {
      await modal.app.plugins.disablePluginAndSave(id);
      condition2 ? await modal.app.plugins.enablePlugin(id) : await modal.app.plugins.enablePluginAndSave(id);
      installed[id].enabled = true;
    }
  }
};
var groupMenuQPS = (evt, modal, groupNumber, span) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed } = settings;
  const inGroup = getPluginsInGroup(modal, groupNumber);
  const menu = new import_obsidian.Menu();
  menu.addItem(
    (item) => item.setTitle("Delay group (or dblclick icon)").onClick(() => {
      addDelayToGroup(modal, groupNumber, span, inGroup);
    })
  );
  menu.addSeparator();
  menu.addItem(
    (item) => item.setTitle("Show/hide group content").onClick(async () => {
      await hideOnCLick(modal, groupNumber, inGroup);
    })
  );
  menu.addSeparator();
  const toEnable = inGroup.filter((id) => installed[id].enabled === false);
  menu.addItem(
    (item) => item.setTitle("Enable all plugins in group").setDisabled(!inGroup.length || !toEnable.length).onClick(async () => {
      if (toEnable) {
        await Promise.all(
          toEnable.map(async (id) => {
            conditionalEnable(modal, id);
            installed[id].enabled = true;
            modal.plugin.saveSettings();
          })
        );
        plugin.getLength();
        new import_obsidian.Notice("All plugins enabled.", 2500);
        await reOpenModal(modal);
      }
    })
  );
  const toDisable = inGroup.filter((id) => installed[id].enabled === true);
  menu.addItem(
    (item) => item.setTitle("Disable all plugins in group").setDisabled(!inGroup.length || !toDisable.length).onClick(async () => {
      if (toDisable) {
        await Promise.all(
          toDisable.map(async (id) => {
            modal.app.plugins.disablePluginAndSave(
              id
            );
            installed[id].enabled = false;
          })
        );
        plugin.getLength();
        new import_obsidian.Notice("All plugins disabled.", 2500);
        await reOpenModal(modal);
      }
    })
  );
  menu.addSeparator();
  createClearGroupsMenuItem(modal, menu, groupNumber);
  menu.showAtMouseEvent(evt);
};
var groupMenuCPM = async (evt, modal, groupNumber) => {
  const menu = new import_obsidian.Menu();
  menu.addItem((item) => {
    item.setTitle("Install & enable in group");
    item.onClick(async () => {
      const inGroup = getPluginsInGroup(
        modal,
        groupNumber
      );
      if (!inGroup.length)
        return;
      await installAllPluginsInGroup(modal, inGroup, true);
    });
  });
  menu.addItem((item) => {
    item.setTitle("Install plugins in group");
    item.onClick(async () => {
      const inGroup = getPluginsInGroup(
        modal,
        groupNumber
      );
      if (!inGroup.length)
        return;
      await installAllPluginsInGroup(modal, inGroup);
    });
  });
  menu.addItem((item) => {
    item.setTitle("Uninstall plugins in group");
    item.onClick(async () => {
      await uninstallAllPluginsInGroup(modal, groupNumber);
    });
  });
  if (modal.app.isMobile) {
    menu.addSeparator();
    const inGroup = getPluginsInGroup(
      modal,
      groupNumber
    );
    menu.addItem(
      (item) => item.setTitle("Show/hide group content").onClick(async () => {
        await hideOnCLick(modal, groupNumber, inGroup);
      })
    );
  }
  menu.addSeparator();
  createClearGroupsMenuItem(modal, menu, groupNumber);
  menu.showAtMouseEvent(evt);
};
var groupMenu = async (evt, modal, groupNumber, span) => {
  if (modal instanceof QPSModal && span) {
    groupMenuQPS(evt, modal, groupNumber, span);
  } else {
    await groupMenuCPM(evt, modal, groupNumber);
  }
};
async function uninstallAllPluginsInGroup(modal, groupNumber) {
  const inGroup = getPluginsInGroup(modal, groupNumber);
  if (!inGroup.length)
    return;
  const { plugin } = modal;
  const { settings } = plugin;
  const { commPlugins } = settings;
  for (const id of inGroup) {
    if (!isInstalled(id))
      continue;
    await this.app.plugins.uninstallPlugin(id);
    new import_obsidian.Notice(`${commPlugins[id].name} uninstalled`, 2500);
  }
  await reOpenModal(modal);
}
async function installAllPluginsInGroup(modal, inGroup, enable = false) {
  const { plugin } = modal;
  const { settings } = plugin;
  const { commPlugins } = settings;
  for (const id of inGroup) {
    if (isInstalled(id)) {
      new import_obsidian.Notice(`${commPlugins[id].name} already installed`, 2500);
      continue;
    }
    const manifest = await getManifest(modal, id);
    if (!manifest)
      continue;
    const lastVersion = manifest.version;
    await this.app.plugins.installPlugin(commPlugins[id].repo, lastVersion, manifest);
    if (enable) {
      await modal.app.plugins.enablePluginAndSave(id);
      new import_obsidian.Notice(`${commPlugins[id].name} enabled`, 2500);
    }
  }
  await reOpenModal(modal);
}
var getPluginsInGroup = (modal, groupNumber) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed, commPlugins } = settings;
  if (modal instanceof QPSModal)
    return Object.keys(installed).filter(
      (id) => installed[id].groupInfo.groupIndices.indexOf(groupNumber) !== -1
    );
  else {
    return Object.keys(commPlugins).filter(
      (id) => commPlugins[id].groupCommInfo.groupIndices.indexOf(groupNumber) !== -1
    );
  }
};
var setGroupTitle = (modal, Groups2, numberOfGroups) => {
  var _a, _b, _c, _d;
  const { plugin } = modal;
  const { settings } = plugin;
  const currentGroupKeys = Object.keys(Groups2);
  for (let i = 1; i < currentGroupKeys.length; i++) {
    const key = currentGroupKeys[i];
    delete Groups2[key];
  }
  for (let i = 1; i <= numberOfGroups; i++) {
    if (modal instanceof CPModal) {
      if (!settings.groupsComm[i]) {
        settings.groupsComm[i] = {
          name: "",
          hidden: false
        };
      }
      const groupKey = ((_a = settings.groupsComm[i]) == null ? void 0 : _a.name) ? (_b = settings.groupsComm[i]) == null ? void 0 : _b.name : `Group${i}`;
      Groups2[`Group${i}`] = `${groupKey}`;
    } else {
      if (!settings.groups[i]) {
        settings.groups[i] = {
          name: "",
          delayed: false,
          time: 0,
          applied: false,
          hidden: false
        };
      }
      const groupKey = ((_c = settings.groups[i]) == null ? void 0 : _c.name) ? (_d = settings.groups[i]) == null ? void 0 : _d.name : `Group${i}`;
      Groups2[`Group${i}`] = `${groupKey}`;
    }
  }
};
function addRemoveItemGroupMenuItems(modal, submenu, pluginItem, alt) {
  const { plugin } = modal;
  const { settings } = plugin;
  Object.keys(Groups).forEach((groupKey) => {
    var _a, _b;
    const { lengthGroup, groupIndex, groupValue } = getGroupIndexLength(
      modal,
      groupKey
    );
    const isQPS = modal instanceof QPSModal;
    const getGroup = isQPS ? ((_a = pluginItem.groupInfo) == null ? void 0 : _a.groupIndices.indexOf(groupIndex)) !== -1 : ((_b = pluginItem.groupCommInfo) == null ? void 0 : _b.groupIndices.indexOf(groupIndex)) !== -1;
    if (groupKey !== "SelectGroup" && lengthGroup && getGroup) {
      let value = alt ? `remove ${groupValue}` : `${groupValue}`;
      submenu.addItem((subitem) => {
        subitem.setTitle(value).onClick(async () => {
          var _a2, _b2;
          const indexes = isQPS ? (_a2 = pluginItem.groupInfo) == null ? void 0 : _a2.groupIndices : (_b2 = pluginItem.groupCommInfo) == null ? void 0 : _b2.groupIndices;
          removeItem(indexes, groupIndex);
          if (groupIsEmpty(groupIndex, modal)) {
            settings.selectedGroup = "SelectGroup";
          }
          await reOpenModal(modal);
        });
      });
    }
  });
}
var getGroupIndexLength = (modal, groupKey) => {
  const groupIndex = getIndexFromSelectedGroup(groupKey);
  const { settings } = modal.plugin;
  const { installed, commPlugins } = settings;
  let lengthGroup, groupValue;
  if (modal instanceof QPSModal) {
    lengthGroup = Object.keys(installed).filter(
      (id) => installed[id].groupInfo.groupIndices.indexOf(groupIndex) !== -1
    ).length;
    groupValue = Groups[groupKey];
  } else {
    lengthGroup = Object.keys(commPlugins).filter(
      (id) => commPlugins[id].groupCommInfo.groupIndices.indexOf(groupIndex) !== -1
    ).length;
    groupValue = GroupsComm[groupKey];
  }
  return { groupIndex, lengthGroup, groupValue };
};
function addRemoveGroupMenuItems(modal, submenu, groupNumber) {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed, commPlugins, groups, groupsComm } = settings;
  let groupName;
  if (modal instanceof QPSModal) {
    groupName = groupNameFromIndex(Groups, groupNumber);
  } else {
    groupName = groupNameFromIndex(GroupsComm, groupNumber);
  }
  const { lengthGroup, groupValue } = getGroupIndexLength(modal, groupName);
  if (groupName !== "SelectGroup" && lengthGroup) {
    submenu.addItem((subitem) => {
      subitem.setTitle(`${groupValue}`).onClick(async () => {
        let pluginsRemoved = false;
        if (modal instanceof QPSModal) {
          for (const id in installed) {
            const index = installed[id].groupInfo.groupIndices.indexOf(groupNumber);
            if (index !== -1) {
              if (groups[groupNumber].hidden) {
                groups[groupNumber].hidden = false;
                installed[id].groupInfo.hidden = false;
              }
              installed[id].groupInfo.groupIndices.splice(index, 1);
              pluginsRemoved = true;
            }
          }
        } else {
          for (const id in commPlugins) {
            const index = commPlugins[id].groupCommInfo.groupIndices.indexOf(groupNumber);
            if (index !== -1) {
              if (groupsComm[groupNumber].hidden) {
                groupsComm[groupNumber].hidden = false;
                commPlugins[id].groupCommInfo.hidden = false;
              }
              commPlugins[id].groupCommInfo.groupIndices.splice(index, 1);
              pluginsRemoved = true;
            }
          }
        }
        await reOpenModal(modal);
        if (pluginsRemoved) {
          new import_obsidian.Notice(`All plugins removed from ${groupValue}`, 2500);
        } else {
          new import_obsidian.Notice(`No plugins found in ${groupValue} group`, 2500);
        }
      });
    });
  }
}
var addToGroupSubMenu = (submenu, pluginItem, modal, alt) => {
  Object.entries(Groups).forEach(([key, value]) => {
    const groupIndices = modal instanceof QPSModal ? pluginItem.groupInfo.groupIndices : pluginItem.groupCommInfo.groupIndices;
    const groupIndex = getIndexFromSelectedGroup(key);
    if (key !== "SelectGroup") {
      if (alt) {
        value = `add to ${value}`;
      }
      const { groups, installed } = modal.plugin.settings;
      if (import_obsidian.Platform.isDesktop || import_obsidian.Platform.isMobile && groupIndices.indexOf(groupIndex) === -1) {
        submenu.addItem(
          (item) => item.setTitle(value).setDisabled(groupIndices.indexOf(groupIndex) !== -1).onClick(async () => {
            if (groupIndices.length === 6)
              return;
            groupIndices == null ? void 0 : groupIndices.push(groupIndex);
            if (groups[groupIndex].hidden)
              installed[pluginItem.id].groupInfo.hidden = true;
            await reOpenModal(modal);
          })
        );
      }
    }
  });
};
var editGroupName = (modal, span, groupNumber) => {
  var _a, _b;
  const { plugin } = modal;
  const { settings } = plugin;
  const currentValue = (modal instanceof CPModal ? ((_a = settings.groupsComm[groupNumber]) == null ? void 0 : _a.name) || "" : (_b = settings.groups[groupNumber]) == null ? void 0 : _b.name) || "";
  const updateGroupName = (value) => {
    var _a2;
    if (modal instanceof CPModal) {
      settings.groupsComm[groupNumber].name = value || GroupsComm[groupNumber];
      span.textContent = settings.groupsComm[groupNumber].name;
    } else {
      settings.groups[groupNumber].name = value || Groups[groupNumber];
      span.textContent = (_a2 = settings.groups[groupNumber]) == null ? void 0 : _a2.name;
    }
  };
  const handleBlurOrEnter = () => {
    setTimeout(async () => {
      if (!modal.isDblClick && input) {
        updateGroupName(input.value);
        await reOpenModal(modal);
      }
    }, 100);
  };
  const input = createInput(span, currentValue);
  if (!input)
    return;
  input.onblur = handleBlurOrEnter;
  input.onkeydown = (event) => {
    if (event.key === "Enter") {
      handleBlurOrEnter();
    }
  };
};
var getEmojiForGroup = (groupNumber) => {
  const emojis = ["\u{1F7E1}", "\u{1F535}", "\u{1F534}", "\u26AA\uFE0F", "\u{1F7E3}", "\u{1F7E2}"];
  const colors = [
    "#FFD700",
    "#0000FF",
    "#FF0000",
    "#FFFFFF",
    "#800080",
    "#00FF00"
  ];
  return { emoji: emojis[groupNumber - 1], color: colors[groupNumber - 1] };
};
var getCirclesItem = (indices) => {
  const len = indices.length;
  let background = "";
  if (len === 1) {
    const { color } = getEmojiForGroup(indices[len - 1]);
    background = `background: ${color};`;
  } else if (len === 2) {
    const { color: color1 } = getEmojiForGroup(indices[len - 2]);
    const { color: color2 } = getEmojiForGroup(indices[len - 1]);
    background = `background: linear-gradient(90deg, ${color1} 50%, ${color2} 50%);`;
  }
  const content = `<div
            style="${background}"
            class="qps-item-line-group"
            >
            &nbsp;
            </div>
            `;
  return content;
};
function groupIsEmpty(groupIndex, modal) {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed, commPlugins } = settings;
  if (modal instanceof QPSModal) {
    return !Object.keys(installed).some(
      (id) => installed[id].groupInfo.groupIndices.indexOf(groupIndex) !== -1
    );
  } else {
    return !Object.keys(commPlugins).some(
      (id) => commPlugins[id].groupCommInfo.groupIndices.indexOf(groupIndex) !== -1
    );
  }
}
function groupNameFromIndex(groups, index) {
  for (let key in groups) {
    if (key.endsWith(index.toString())) {
      return key;
    }
  }
  return null;
}
function getIndexFromSelectedGroup(str) {
  if (str === "SelectGroup")
    return 0;
  else
    return parseInt(str.slice(-1));
}
async function rmvAllGroupsFromPlugin(modal, pluginItem) {
  const { plugin } = modal;
  if ("repo" in pluginItem) {
    pluginItem.groupCommInfo.groupIndices = [];
    plugin.settings.selectedGroupComm = "SelectGroup";
  } else {
    pluginItem.groupInfo.groupIndices = [];
    plugin.settings.selectedGroup = "SelectGroup";
  }
  await reOpenModal(modal);
}
function groupNbFromEmoticon(el) {
  var _a, _b;
  const groupNameEl = el.nextElementSibling;
  return parseInt((_b = (_a = groupNameEl == null ? void 0 : groupNameEl.querySelector("span")) == null ? void 0 : _a.textContent) != null ? _b : "");
}
function groupNbFromGrpName(groupName) {
  var _a;
  return parseInt((_a = groupName == null ? void 0 : groupName.match(/\((\d+)\)$/)) == null ? void 0 : _a[1]);
}

// src/modal_utils.ts
var reset = async (modal) => {
  const { plugin } = modal;
  const confirmed = await confirm("Reset most switched values?", 250);
  if (confirmed) {
    plugin.reset = true;
    plugin.getLength();
    await reOpenModal(modal);
    new import_obsidian2.Notice("Done", 2500);
  } else {
    new import_obsidian2.Notice("Operation cancelled", 2500);
  }
};
var sortByName = (plugin, listItems) => {
  const { settings } = plugin;
  const { installed } = settings;
  listItems.sort((a, b) => installed[a].name.localeCompare(installed[b].name));
};
var sortSwitched = (plugin, listItems) => {
  const { settings } = plugin;
  const { installed } = settings;
  listItems.sort((a, b) => installed[b].switched - installed[a].switched);
};
var togglePlugin = async (modal, pluginItem) => {
  const { plugin } = modal;
  pluginItem.enabled = !pluginItem.enabled;
  pluginItem.enabled ? await conditionalEnable(modal, pluginItem.id) : await modal.app.plugins.disablePluginAndSave(pluginItem.id);
  plugin.getLength();
  await reOpenModal(modal);
};
async function openDirectoryInFileManager(modal, pluginItem) {
  let shell = window.electron.remote.shell;
  const filePath = modal.app.vault.adapter.getFullPath(
    pluginItem.dir
  );
  try {
    await shell.openPath(filePath);
  } catch (err) {
    const plugins = modal.app.vault.adapter.getFullPath(
      ".obsidian/plugins"
    );
    await shell.openPath(plugins);
  }
}
var delayedReEnable = async (modal, id) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed } = settings;
  await modal.app.plugins.disablePluginAndSave(id);
  await modal.app.plugins.enablePlugin(id);
  installed[id].enabled = true;
};
var conditionalEnable = async (modal, id) => {
  const { installed } = modal.plugin.settings;
  if (installed[id].delayed && installed[id].time > 0) {
    await modal.app.plugins.enablePlugin(id);
    await modal.plugin.saveSettings();
  } else {
    installed[id].switched++;
    await modal.app.plugins.enablePluginAndSave(id);
  }
};
var selectValue = (input) => {
  input == null ? void 0 : input.setSelectionRange(0, input == null ? void 0 : input.value.length);
};
var modeSort = (modal, plugin, listItems) => {
  const { settings } = plugin;
  const { installed, filters } = settings;
  if (plugin.reset) {
    listItems.forEach((id) => {
      installed[id].switched = 0;
    });
    plugin.reset = false;
  }
  if (filters === Filters.enabledFirst) {
    const enabledItems = listItems.filter((id) => installed[id].enabled);
    const disabledItems = listItems.filter((id) => !installed[id].enabled);
    sortByName(plugin, enabledItems);
    sortByName(plugin, disabledItems);
    listItems = [...enabledItems, ...disabledItems];
  } else if (filters === Filters.byGroup) {
    const groupIndex = getIndexFromSelectedGroup(
      settings.selectedGroup
    );
    if (groupIndex !== 0) {
      const groupedItems = listItems.filter((i) => {
        return installed[i].groupInfo.groupIndices.indexOf(groupIndex) !== -1;
      });
      listItems = groupedItems;
      sortByName(plugin, listItems);
    } else {
      sortByName(plugin, listItems);
    }
  } else if (filters === Filters.mostSwitched) {
    sortByName(plugin, listItems);
    sortSwitched(plugin, listItems);
  } else if (filters === Filters.hidden) {
    return getHidden(modal, listItems);
  } else {
    sortByName(plugin, listItems);
  }
  return listItems;
};
function createInput(el, currentValue) {
  if (el) {
    const input = document.createElement("input");
    input.type = "text";
    input.value = currentValue;
    el.replaceWith(input);
    input.focus();
    selectValue(input);
    return input;
  } else {
    return void 0;
  }
}
var pressDelay = (modal) => {
  modal.pressed = true;
  setTimeout(() => {
    modal.pressed = false;
  }, 1);
};
function getInstalled() {
  return Object.keys(this.app.plugins.manifests);
}
function getHidden(modal, listItems) {
  const { settings } = modal.plugin;
  const { installed, commPlugins } = settings;
  let hiddens;
  if (modal instanceof QPSModal) {
    hiddens = listItems.filter((key) => installed[key].groupInfo.hidden === true);
  } else {
    hiddens = listItems.filter((key) => commPlugins[key].groupCommInfo.hidden === true);
  }
  return listItems.filter((item) => hiddens.includes(item));
}
function getHasNote(modal, listItems) {
  return listItems.filter((item) => modal.plugin.settings.commPlugins[item].hasNote);
}
function isInstalled(id) {
  return getInstalled().includes(id);
}
async function reOpenModal(modal, searchInit = false) {
  await modal.plugin.saveSettings();
  modal.searchInit = searchInit;
  await modal.onOpen();
}
async function openPluginSettings(evt, modal, pluginItem) {
  var _a;
  evt.preventDefault();
  const enabled = (_a = modal.plugin.settings.installed[pluginItem.id]) == null ? void 0 : _a.enabled;
  if (!enabled) {
    new import_obsidian2.Notice("Plugin disabled, no Settings to show", 3500);
    return;
  }
  const pluginSettings = modal.app.setting.openTabById(
    pluginItem.id
  );
  if (!pluginSettings) {
    new import_obsidian2.Notice("No Settings on this plugin", 2500);
    return;
  }
  modal.app.setting.open();
  await (pluginSettings == null ? void 0 : pluginSettings.display());
}
var showHotkeysFor = async function(evt, modal, pluginItem) {
  evt.preventDefault();
  const enabled = modal instanceof CPModal ? modal.plugin.settings.installed[pluginItem.id].enabled : pluginItem.enabled;
  if (!enabled) {
    new import_obsidian2.Notice("Plugin disabled, no HotKeys to show", 3500);
    return;
  }
  const condition2 = await getHkeyCondition(modal, pluginItem);
  if (!condition2) {
    new import_obsidian2.Notice("No HotKeys on this plugin", 2500);
    return;
  }
  await this.app.setting.open();
  await this.app.setting.openTabById("hotkeys");
  const tab = await this.app.setting.activeTab;
  tab.searchComponent.inputEl.value = pluginItem.name + ":";
  tab.updateHotkeyVisibility();
  tab.searchComponent.inputEl.blur();
};
function modifyGitHubLinks(content, pluginItem) {
  content = content.replace(/\/blob\/master/g, "/raw/HEAD");
  const imgRegex = /(!\[([^\]]*)\]\(([^)]*)\))/g;
  content.replace(imgRegex, (match, alt, url) => {
    if (!url.startsWith("http")) {
      if (url.startsWith(".")) {
        url = `https://github.com/${pluginItem.repo}/raw/HEAD${url.substr(1)}`;
      } else {
        url = `https://github.com/${pluginItem.repo}/raw/HEAD/${url}`;
      }
    }
    return `![${alt}](${url})`;
  });
  const ImgSrc = /(<img\s[^>]*src="\s*)(\.?\/?[^"]+)"[^>]*>/gi;
  content = content.replace(ImgSrc, (match, prefix, url) => {
    if (!url.startsWith("http")) {
      if (url.startsWith(".")) {
        url = `https://github.com/${pluginItem.repo}/raw/HEAD${url.substr(1)}`;
      } else {
        url = `https://github.com/${pluginItem.repo}/raw/HEAD/${url}`;
      }
    }
    return `${prefix}${url}"`;
  });
  return content;
}
function getElementFromMousePosition(modal) {
  if (modal.mousePosition) {
    const elementFromPoint = document.elementFromPoint(
      modal.mousePosition.x,
      modal.mousePosition.y
    );
    return elementFromPoint;
  }
  return null;
}
function focusSearchInput(time) {
  setTimeout(() => {
    var _a;
    (_a = document.querySelector(".qps-search-component input")) == null ? void 0 : _a.focus();
  }, time);
}

// src/community-plugins_modal.ts
var path = __toESM(require("path"));

// src/Console.ts
var import_obsidian3 = require("obsidian");
var disableAnyway = false;
var DEBUG = "false";
if (import_obsidian3.Platform.isDesktopApp) {
  require_main().config();
  DEBUG = "false";
}
var condition = DEBUG.trim().toLowerCase() === "true" && !disableAnyway;
var Console = {
  debug: (...args) => {
    if (condition) {
      console.debug(...args);
    }
  },
  log: (...args) => {
    if (condition) {
      console.log(...args);
    }
  }
};

// src/translate.ts
var import_obsidian4 = require("obsidian");
function canTranslate() {
  return this.plugin.translator && this.plugin.translator.valid;
}
async function translate(text, from) {
  let to = "";
  const plugin = this.app.plugins.plugins.translate;
  if (!plugin) {
    new import_obsidian4.Notice(
      "install obsidian-translate and select a translator"
    );
    return;
  }
  if (!canTranslate) {
    new import_obsidian4.Notice("translator not valid. check your settings", 4e3);
    return;
  }
  const loaded_settings = await plugin.loadData();
  if (loaded_settings.target_language_preference === "last") {
    to = loaded_settings.last_used_target_languages[0];
  } else if (loaded_settings.target_language_preference === "specific") {
    to = loaded_settings.default_target_language;
  } else if (loaded_settings.target_language_preference === "display") {
    to = plugin.current_language;
  }
  return plugin.translator.translate(text, from, to);
}
async function translation(selectedContent) {
  if (!selectedContent) {
    new import_obsidian4.Notice("no content selected", 2e3);
    return;
  }
  const translated = await translate(selectedContent, "en");
  if (!translated)
    return;
  const translation2 = translated.translation;
  if (!translation2) {
    new import_obsidian4.Notice("translator not valid. check your settings", 4e3);
    return;
  }
  new TranslateModal(this.app, translation2).open();
}
var TranslateModal = class extends import_obsidian4.Modal {
  constructor(app, message) {
    super(app);
    this.message = message;
    this.modalEl.addClass("translate-modal");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const lines = this.message.split("\n");
    lines.forEach((line) => contentEl.createEl("p").setText(line));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/community-plugins_modal.ts
var CPModal = class extends import_obsidian5.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.searchTyping = true;
    this.isDblClick = false;
    this.pressed = false;
    this.searchInit = true;
    this.getMousePosition = (event) => {
      this.mousePosition = { x: event.clientX, y: event.clientY };
    };
    this.getHandleKeyDown = async (event) => {
      await handleKeyDown(event, this);
    };
    this.getHandleContextMenu = async (evt) => {
      if (this.isDblClick)
        return;
      await handleContextMenu(evt, this);
    };
    this.getHandleDblClick = (evt) => {
      if (this.isDblClick)
        return;
      handleDblClick(evt, this);
    };
    this.getHandleClick = (evt) => {
      if (this.isDblClick)
        return;
      handleClick(evt, this);
    };
    this.getHandleTouch = (evt) => {
      if (this.isDblClick)
        return;
      handleTouchStart(evt, this);
    };
    this.addHeader = (contentEl) => {
      const { plugin } = this;
      const { settings } = plugin;
      new import_obsidian5.DropdownComponent(contentEl).addOptions({
        all: `All(${Object.keys(settings.commPlugins).length})`,
        installed: `Installed(${getInstalled().length})`,
        notInstalled: import_obsidian5.Platform.isMobile ? "Not Installed" : `Not Installed(${Object.keys(settings.commPlugins).length - getInstalled().length})`,
        byGroup: `By Group`,
        hidden: `Hidden(${getHidden(this, Object.keys(settings.commPlugins)).length})`,
        hasNote: `With Note(${getHasNote(this, Object.keys(settings.commPlugins)).length})`
      }).setValue(settings.filtersComm).onChange(async (value) => {
        settings.filtersComm = value;
        await plugin.saveSettings();
        await reOpenModal(this);
      });
      byGroupDropdowns(this, contentEl);
      getFilters(this, contentEl);
      checkbox(this, contentEl, "Inv");
    };
    this.plugin = plugin;
  }
  removeListeners() {
    this.modalEl.removeEventListener("mousemove", this.getMousePosition);
    document.removeEventListener("keydown", this.getHandleKeyDown);
    this.modalEl.removeEventListener("contextmenu", this.getHandleContextMenu);
    if (import_obsidian5.Platform.isDesktop) {
      this.modalEl.removeEventListener("dblclick", this.getHandleDblClick);
      this.modalEl.removeEventListener("click", this.getHandleClick);
    }
    if (import_obsidian5.Platform.isMobile) {
      this.modalEl.removeEventListener("touchstart", this.getHandleTouch);
    }
  }
  container() {
    const { contentEl } = this;
    this.modalEl.addClass("community-plugins-modal");
    this.header = contentEl.createEl("div", {
      cls: "qps-community-header"
    });
    this.search = contentEl.createEl("div", {
      cls: "qps-community-search"
    });
    this.groups = contentEl.createEl("div", {
      cls: ["qps-community-groups", "qps-comm-group"]
    });
    this.hotkeysDesc = contentEl.createEl("p", { cls: "qps-hk-desc" });
    this.items = contentEl.createEl("div", { cls: "qps-community-items" });
    this.modalEl.addEventListener("mousemove", this.getMousePosition);
    document.addEventListener("keydown", this.getHandleKeyDown);
    this.modalEl.addEventListener("contextmenu", this.getHandleContextMenu);
    if (import_obsidian5.Platform.isDesktop) {
      this.modalEl.addEventListener("dblclick", this.getHandleDblClick);
      this.modalEl.addEventListener("click", this.getHandleClick);
    }
    if (import_obsidian5.Platform.isMobile) {
      this.modalEl.addEventListener("touchstart", this.getHandleTouch);
    }
  }
  async onOpen() {
    this.removeListeners();
    const { plugin, contentEl } = this;
    const { settings } = plugin;
    if (this.searchInit)
      settings.search = "";
    this.searchInit = true;
    contentEl.empty();
    this.container();
    setGroupTitle(this, GroupsComm, settings.numberOfGroupsComm);
    this.addHeader(this.header);
    await addSearch(this, this.search, "Search community plugins");
    if (import_obsidian5.Platform.isDesktopApp) {
      searchCommDivButton(this, this.search);
    }
    this.addGroups(this, this.groups);
    if (settings.showHotKeys && !this.app.isMobile)
      this.setHotKeysdesc();
    await this.addItems(settings.search);
  }
  addGroups(modal, contentEl) {
    const groups = Object.values(GroupsComm);
    for (let i = 1; i < groups.length; i++) {
      const groupKey = groups[i];
      contentEl.createEl(
        "span",
        {
          cls: "qps-group-span-container"
        },
        (cont) => {
          const preSpan = cont.createEl(
            "span",
            {
              cls: "qps-circle-title-group"
            },
            (el) => {
              circleCSSModif(this, el, i);
            }
          );
          const span = cont.createEl("span", {
            cls: "qps-groups-name",
            text: `${groupKey}`
          }, (el) => {
            var _a;
            const { plugin } = modal;
            const { settings } = plugin;
            const hidden = (_a = settings.groupsComm[i]) == null ? void 0 : _a.hidden;
            if (hidden) {
              el.style.textDecoration = "line-through";
              el.style.opacity = "0.6";
            } else {
              el.style.textDecoration = "none";
            }
          });
          const groupNumberText = `(<span class="shortcut-number">${i}</span>)`;
          span.insertAdjacentHTML("beforeend", groupNumberText);
        }
      );
    }
    if (!this.app.isMobile) {
      contentEl.createSpan({
        text: `> (h)\u{1F441}\uFE0F (\u{1F5B1}\uFE0Fx2)name`
      });
    } else {
      contentEl.createSpan({
        text: `(\u{1F5B1}\uFE0Fx2)name,icon:delay (\u{1F5B1}\uFE0F...)context-menu`
      });
    }
  }
  setHotKeysdesc() {
    const numberOfGroups = this.plugin.settings.numberOfGroupsComm;
    this.hotkeysDesc.createSpan(
      {
        text: `(1-${numberOfGroups})\u2795 (0)\u274C `
      },
      (el) => {
        el.createSpan({ text: "(g)" }, (el2) => {
          let gitHubIcon = el2.createSpan({ cls: "git-hub-icon" });
          (0, import_obsidian5.setIcon)(gitHubIcon, "github");
        });
        el.createSpan({
          text: ` (\u{1F5B1}\uFE0Fx2/ctrl)Readme `
        });
        el.createSpan({ text: "(n)\u{1F4DD} " });
        el.createSpan({ text: "(s)\u{1F4CA} " });
        el.createSpan({ text: "(t)translate" });
      }
    );
  }
  async addItems(value) {
    const { plugin } = this;
    const { settings } = plugin;
    const { commPlugins, pluginStats } = settings;
    let listItems = doSearchCPM(value, commPlugins);
    listItems = cpmModeSort(this, listItems);
    sortItemsBy.bind(this)(this, listItems);
    await this.drawItemsAsync.bind(this)(listItems, pluginStats, value);
  }
  hightLightSpan(value, text) {
    if (value.trim() === "") {
      return text;
    } else {
      const regex = new RegExp(`(${value})`, "gi");
      return text.replace(regex, `<span class="highlighted">$&</span>`);
    }
  }
  async drawItemsAsync(listItems, pluginStats, value) {
    const batchSize = 50;
    let index = 0;
    const { plugin } = this;
    const { settings } = plugin;
    const { commPlugins, filtersComm } = settings;
    while (index < listItems.length) {
      const batch = listItems.slice(index, index + batchSize);
      const promises = batch.map(async (item) => {
        var _a, _b;
        if (((_a = commPlugins[item].groupCommInfo) == null ? void 0 : _a.hidden) && !commPlugins[item].groupCommInfo.groupIndices.length) {
          commPlugins[item].groupCommInfo.hidden = false;
        }
        if (filtersComm !== CommFilters.byGroup) {
          if (((_b = commPlugins[item].groupCommInfo) == null ? void 0 : _b.hidden) && filtersComm === "all") {
            return;
          }
        }
        const itemContainer = this.items.createEl("div", { cls: "qps-comm-block" });
        if (this.app.isMobile) {
          itemContainer.createEl(
            "div",
            {
              cls: "button-container"
            },
            (el) => {
              vertDotsButton(el);
            }
          );
        }
        const notesButtonContainer = itemContainer.createEl(
          "div",
          {
            cls: "button-container1"
          },
          (el) => {
            notesButton(el, this, commPlugins[item]);
          }
        );
        if (import_obsidian5.Platform.isDesktop) {
          notesButtonContainer.addClass("button-container1-desktop");
        }
        if (commPlugins[item].hasNote) {
          notesButtonContainer.addClass("notes-button-background");
        }
        const name = this.hightLightSpan(value, commPlugins[item].name);
        const author = `by ${this.hightLightSpan(value, commPlugins[item].author)}`;
        const desc = this.hightLightSpan(value, commPlugins[item].description);
        itemContainer.createDiv(
          { cls: "qps-community-item-name" },
          (el) => {
            el.innerHTML = name;
            if (isInstalled(item)) {
              el.createSpan({ cls: "installed-span", text: "installed" });
            }
            if (isEnabled(this, item)) {
              const span = el.createSpan({ cls: "enabled-span" });
              (0, import_obsidian5.setIcon)(span, "power");
            }
          }
        );
        itemContainer.createDiv({ cls: "qps-community-item-author" });
        const pluginInfo = pluginStats[item];
        itemContainer.createDiv(
          { cls: "qps-community-item-downloads" },
          (el) => {
            el.innerHTML = author;
            el.createSpan({ cls: "downloads-span" }, (el2) => {
              const preSpan = el2.createSpan();
              const text = pluginInfo ? formatNumber(pluginInfo.downloads, 1).toString() : "0";
              const span = el2.createSpan({
                text,
                cls: "downloads-text-span"
              });
              addGroupCircles(this, span, item);
              (0, import_obsidian5.setIcon)(preSpan, "download-cloud");
            });
          }
        );
        const lastUpdated = pluginInfo ? new Date(pluginInfo.updated) : null;
        const timeSinceUpdate = lastUpdated ? calculateTimeElapsed(lastUpdated) : "";
        itemContainer.createDiv({
          cls: "qps-community-item-updated",
          text: lastUpdated ? `Updated ${timeSinceUpdate}` : "Updated: not available yet"
        });
        itemContainer.createDiv({ cls: "qps-community-item-desc" }, (el) => {
          el.innerHTML = desc;
        });
        return itemContainer;
      });
      await Promise.all(promises);
      index += batchSize;
    }
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.removeListeners();
    await this.plugin.installedUpdate();
    new QPSModal(this.app, this.plugin).open();
    focusSearchInput(100);
  }
};
async function fetchData(url) {
  try {
    const response = await (0, import_obsidian5.requestUrl)(url);
    const data = await response.json;
    if (data)
      return data;
  } catch (error) {
    return null;
  }
}
async function getReadMe(item) {
  const repo = item.repo;
  const readmeFormats = ["README.md", "README.org"];
  for (const format of readmeFormats) {
    const repoURL = `https://api.github.com/repos/${repo}/contents/${format}`;
    try {
      const response = await (0, import_obsidian5.requestUrl)(repoURL);
      if (response.status === 200) {
        return await response.json;
      }
      if (format === "README.md") {
        break;
      }
    } catch (error) {
      console.warn(`Error fetching ${format}`);
    }
  }
  return null;
}
async function getManifest(modal, id) {
  var _a;
  const { commPlugins } = modal.plugin.settings;
  const repo = (_a = commPlugins[id]) == null ? void 0 : _a.repo;
  const repoURL = `https://raw.githubusercontent.com/${repo}/HEAD/manifest.json`;
  try {
    const response = await (0, import_obsidian5.requestUrl)(repoURL);
    return await response.json;
  } catch (error) {
    Console.log("id, commPlugins[id]", id, commPlugins[id]);
    console.warn("Error fetching manifest");
  }
  return null;
}
async function getReleaseVersion(modal, id, manifest) {
  const { commPlugins } = modal.plugin.settings;
  const repo = commPlugins[id].repo;
  const releaseUrl = `https://github.com/${repo}/releases/tag/${manifest.version}`;
  try {
    const response = await (0, import_obsidian5.requestUrl)(releaseUrl);
    if (response)
      return true;
    return false;
  } catch (e) {
    return false;
  }
}
function sortItemsBy(modal, listItems) {
  const { settings } = modal.plugin;
  const { commPlugins } = settings;
  if (settings.sortBy === "Downloads") {
    listItems.sort((a, b) => {
      return settings.invertFiltersComm ? commPlugins[a].downloads - commPlugins[b].downloads : commPlugins[b].downloads - commPlugins[a].downloads;
    });
  } else if (settings.sortBy === "Updated") {
    listItems.sort((a, b) => {
      return settings.invertFiltersComm ? commPlugins[a].updated - commPlugins[b].updated : commPlugins[b].updated - commPlugins[a].updated;
    });
  } else if (settings.sortBy === "Alpha") {
    listItems.sort((a, b) => {
      return settings.invertFiltersComm ? commPlugins[b].name.localeCompare(commPlugins[a].name) : commPlugins[a].name.localeCompare(commPlugins[b].name);
    });
  } else if (settings.sortBy === "Released") {
    listItems.sort((a, b) => {
      const indexA = settings.plugins.findIndex((id) => id === commPlugins[a].id);
      const indexB = settings.plugins.findIndex((id) => id === commPlugins[b].id);
      return settings.invertFiltersComm ? indexA - indexB : indexB - indexA;
    });
  }
}
function cpmModeSort(modal, listItems) {
  const { settings } = modal.plugin;
  const { filtersComm, commPlugins } = settings;
  if (filtersComm === CommFilters.installed) {
    const installedPlugins = getInstalled();
    return listItems.filter((item) => installedPlugins.includes(item));
  } else if (filtersComm === CommFilters.notInstalled) {
    const installedPlugins = getInstalled();
    return listItems.filter((item) => !installedPlugins.includes(item));
  } else if (filtersComm === CommFilters.hasNote) {
    const liste = listItems.filter((item) => commPlugins[item].hasNote);
    return liste;
  } else if (filtersComm === CommFilters.byGroup) {
    const groupIndex = getIndexFromSelectedGroup(
      settings.selectedGroup
    );
    if (groupIndex !== 0) {
      const groupedItems = listItems.filter((i) => {
        var _a;
        return ((_a = commPlugins[i].groupCommInfo) == null ? void 0 : _a.groupIndices.indexOf(groupIndex)) !== -1;
      });
      return groupedItems;
    } else
      return listItems;
  } else if (filtersComm === "hidden") {
    return getHidden(modal, listItems);
  } else if (filtersComm === "hasNote") {
    return getHasNote(modal, listItems);
  } else {
    return listItems;
  }
}
var handleKeyDown = async (event, modal) => {
  var _a;
  const elementFromPoint = getElementFromMousePosition(modal);
  const targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-comm-block"
  );
  const targetGroupIcon = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-circle-title-group"
  );
  const targetGroup = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-groups-name"
  );
  if (targetBlock) {
    (_a = document.querySelector(".qps-search-component input")) == null ? void 0 : _a.blur();
    modal.searchTyping = false;
    const matchingItem = findMatchingItem(modal, targetBlock);
    if (matchingItem) {
      event.preventDefault();
      await handleHotkeysCPM(
        modal,
        event,
        matchingItem
      );
    }
  } else if ((targetGroupIcon || targetGroup) && event.key === "h") {
    modal.searchTyping = false;
    await toggleVisibility(modal, targetGroupIcon, targetGroup);
  } else {
    modal.searchTyping = true;
  }
};
var handleHotkeysCPM = async (modal, evt, pluginItem) => {
  if (modal.pressed) {
    return;
  }
  pressDelay(modal);
  const { plugin } = modal;
  const { settings } = plugin;
  const { groupsComm, commPlugins } = settings;
  const numberOfGroups = settings.numberOfGroupsComm;
  const KeyToSettingsMap = {
    g: async () => await openGitHubRepo(evt, modal, pluginItem),
    n: async () => await handleNote(evt, modal, pluginItem),
    s: async () => showStats(pluginItem),
    t: async () => {
      var _a;
      const selectedContent = (_a = getSelectedContent()) != null ? _a : "";
      await translation(selectedContent);
    }
  };
  const keyPressed = evt.key;
  let groupIndices = pluginItem.groupCommInfo.groupIndices;
  const key = parseInt(keyPressed);
  if (key > 0 && key <= numberOfGroups) {
    if (groupIndices.length === 6)
      return;
    const index = groupIndices.indexOf(key);
    if (index === -1) {
      groupIndices.push(key);
      if (groupsComm[key].hidden)
        commPlugins[pluginItem.id].groupCommInfo.hidden = true;
      await reOpenModal(modal);
    }
  } else if (keyPressed in KeyToSettingsMap) {
    KeyToSettingsMap[keyPressed]();
  } else if (evt.metaKey || evt.ctrlKey) {
    new ReadMeModal(plugin.app, modal, pluginItem).open();
  } else if (keyPressed === "Delete" || keyPressed === "Backspace" || keyPressed === "0") {
    if (groupIndices.length === 1) {
      pluginItem.groupCommInfo.groupIndices = [];
      await plugin.saveSettings();
      await reOpenModal(modal);
    } else if (groupIndices.length > 1) {
      const menu = new import_obsidian5.Menu();
      menu.addItem(
        (item) => item.setTitle("Remove item group(s)").setDisabled(true).setDisabled(true)
      );
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle("All").onClick(async () => {
          await rmvAllGroupsFromPlugin(modal, pluginItem);
        })
      );
      for (const groupIndex of groupIndices) {
        const { emoji } = getEmojiForGroup(groupIndex);
        menu.addItem(
          (item) => item.setTitle(`${emoji} group ${groupIndex}`).onClick(async () => {
            groupIndices = removeItem(
              groupIndices,
              groupIndex
            );
            await plugin.saveSettings();
            await reOpenModal(modal);
          })
        );
      }
      menu.showAtPosition(modal.mousePosition);
    }
  }
};
var addGroupCircles = (modal, el, item) => {
  const { settings } = modal.plugin;
  const { commPlugins } = settings;
  const indices = commPlugins[item].groupCommInfo.groupIndices;
  if (indices.length) {
    if (indices.length < 3) {
      const content = getCirclesItem(indices);
      el.insertAdjacentHTML("afterend", content);
    }
    if (indices.length >= 3 && indices.length < 5) {
      const [valeur0, valeur1, ...part2] = indices;
      const part1 = [valeur0, valeur1];
      const content1 = getCirclesItem(part1);
      el.insertAdjacentHTML("afterend", content1);
      const content2 = getCirclesItem(part2);
      el.insertAdjacentHTML("afterend", content2);
    } else if (indices.length >= 5) {
      const [valeur0, valeur1, valeur2, valeur3, ...part3] = indices;
      const part1 = [valeur0, valeur1];
      const part2 = [valeur2, valeur3];
      const content1 = getCirclesItem(part1);
      el.insertAdjacentHTML("afterend", content1);
      const content2 = getCirclesItem(part2);
      el.insertAdjacentHTML("afterend", content2);
      const content3 = getCirclesItem(part3);
      el.insertAdjacentHTML("afterend", content3);
    }
  }
};
async function installFromList(modal, enable = false) {
  let properties = ["openFile"];
  let filePaths = window.electron.remote.dialog.showOpenDialogSync({
    title: "Pick json list file of plugins to install",
    properties,
    filters: ["JsonList", "json"]
  });
  if (filePaths && filePaths.length) {
    const contenu = (0, import_fs.readFileSync)(filePaths[0], "utf-8");
    try {
      const pluginList = JSON.parse(contenu);
      if (Array.isArray(pluginList)) {
        const plugins = Object.keys(modal.plugin.settings.commPlugins).filter(
          (id) => {
            return pluginList.includes(id);
          }
        );
        await installAllPluginsInGroup(modal, plugins, enable);
      } else {
        console.error("this file is not a JSON list.");
      }
    } catch (erreur) {
      console.error("Error reading JSON file: ", erreur);
    }
  }
}
async function getPluginsList(modal, enable = false) {
  const installed = getInstalled();
  let filePath = window.electron.remote.dialog.showSaveDialogSync({
    title: "Save installed plugins list as JSON",
    filters: [{ name: "JSON Files", extensions: ["json"] }]
  });
  if (filePath && filePath.length) {
    try {
      const jsonContent = JSON.stringify(installed, null, 2);
      (0, import_fs.writeFileSync)(filePath, jsonContent);
      new import_obsidian5.Notice(`${filePath} created`, 2500);
    } catch (error) {
      console.error("Error saving JSON file:", error);
    }
  }
}
async function installPluginFromOtherVault(modal, enable = false) {
  let dirPath = window.electron.remote.dialog.showOpenDialogSync({
    title: "Select your vault directory, you want plugins list from",
    properties: ["openDirectory"]
  });
  if (dirPath && dirPath.length) {
    const vaultPath = dirPath[0];
    const obsidianPath = path.join(vaultPath, ".obsidian");
    if (!(0, import_fs.existsSync)(obsidianPath)) {
      new import_obsidian5.Notice("Select a vault folder!", 2500);
      return;
    }
    const selectedVaultName = path.basename(vaultPath);
    const currentVaultName = modal.app.vault.getName();
    if (selectedVaultName === currentVaultName) {
      new import_obsidian5.Notice("You have selected the current vault!", 2500);
      return;
    }
    const pluginsPath = path.join(obsidianPath, "plugins");
    if (!(0, import_fs.existsSync)(pluginsPath)) {
      new import_obsidian5.Notice(
        "This vault doesn't contain any installed plugin!",
        2500
      );
      return;
    }
    const installedPlugins = [];
    const pluginFolders = (0, import_fs.readdirSync)(pluginsPath);
    for (const pluginFolder of pluginFolders) {
      const pluginFolderPath = path.join(pluginsPath, pluginFolder);
      const packageJsonPath = path.join(pluginFolderPath, "package.json");
      const manifestJsonPath = path.join(
        pluginFolderPath,
        "manifest.json"
      );
      const mainJsPath = path.join(pluginFolderPath, "main.js");
      if ((0, import_fs.existsSync)(packageJsonPath)) {
        continue;
      }
      if ((0, import_fs.existsSync)(manifestJsonPath) && (0, import_fs.existsSync)(mainJsPath)) {
        const manifestContent = (0, import_fs.readFileSync)(manifestJsonPath, "utf-8");
        const manifestData = JSON.parse(manifestContent);
        const pluginId = manifestData.id;
        installedPlugins.push(pluginId);
      }
    }
    if (!installedPlugins.length) {
      new import_obsidian5.Notice("Found no plugin to install", 2500);
      return;
    }
    const plugins = Object.keys(modal.plugin.settings.commPlugins).filter((id) => {
      return installedPlugins.includes(id);
    });
    await installAllPluginsInGroup(modal, plugins, enable);
  }
}
async function updateNotes(plugin) {
  const name = "Community plugins notes";
  const dir = plugin.settings.commPluginsNotesFolder;
  let note;
  const path3 = dir ? dir + "/" + name + ".md" : name + ".md";
  note = this.app.vault.getAbstractFileByPath(path3);
  if (note) {
    let content = note ? await this.app.vault.read(note) : "";
    const h1Titles = content.split("\n").filter((line) => line.startsWith("# ")).map((line) => line.substring(2).trim());
    const { commPlugins } = plugin.settings;
    Object.values(commPlugins).forEach((plugin2) => {
      if (plugin2.hasNote && !h1Titles.includes(plugin2.name)) {
        plugin2.hasNote = false;
      } else if (!plugin2.hasNote && h1Titles.includes(plugin2.name)) {
        plugin2.hasNote = true;
      }
    });
  }
}
async function handleNote(e, modal, pluginItem, _this) {
  const name = "Community plugins notes";
  const dir = modal.plugin.settings.commPluginsNotesFolder;
  let note;
  if (dir && !modal.app.vault.getAbstractFileByPath(dir)) {
    await modal.app.vault.createFolder(dir);
  }
  const path3 = dir ? dir + "/" + name + ".md" : name + ".md";
  note = modal.app.vault.getAbstractFileByPath(path3);
  if (!note) {
    await modal.app.vault.create(path3, "");
    note = modal.app.vault.getAbstractFileByPath(path3);
  }
  let content = note ? await modal.app.vault.read(note) : "";
  const savedContent = content;
  const sectionHeader = "# " + pluginItem.name;
  const sectionIndex = content.indexOf(sectionHeader);
  let sectionContent = "";
  if (sectionIndex !== -1) {
    Console.log("exists");
    const contentAfterSection = content.substring(sectionIndex);
    const nextSectionIndex = contentAfterSection.indexOf("\n# ", sectionHeader.length);
    sectionContent = nextSectionIndex !== -1 ? contentAfterSection.substring(0, nextSectionIndex) : contentAfterSection;
    sectionContent = sectionContent.replace(sectionHeader + "\n\n", "");
  } else {
    Console.log("append");
    if (content && !content.endsWith("\n")) {
      content = content + "\n";
    }
    const added = content ? content + "\n" + sectionHeader + "\n\n" : sectionHeader + "\n\n";
    Console.log("added", added);
    await modal.app.vault.modify(note, added);
    content = await modal.app.vault.read(note);
    sectionContent = "";
  }
  new SeeNoteModal(modal.app, modal, pluginItem, sectionContent, async (result) => {
    await cb(result, modal, pluginItem, sectionContent, note, content, savedContent, _this);
  }, _this).open();
}
async function cb(result, modal, pluginItem, sectionContent, note, content, savedContent, _this) {
  Console.log("sectionContent", sectionContent);
  Console.log("result", result);
  if (result === null) {
    Console.log("invalid content");
    const updatedContent = content.replace(sectionContent, "");
    await modal.app.vault.modify(note, updatedContent);
    content = await modal.app.vault.read(note);
    return;
  }
  if (result.trim() === "") {
    Console.log(" resut has no content");
    let updatedContent = "";
    const regexPattern = new RegExp("# " + pluginItem.name + "\n\n?" + sectionContent + "\n?", "g");
    updatedContent = content.replace(regexPattern, "");
    Console.log("updatedContent", updatedContent);
    await modal.app.vault.modify(note, updatedContent);
    pluginItem.hasNote = false;
    await modal.plugin.saveSettings();
    if (_this) {
      _this.onOpen();
      modal.searchInit = false;
      modal.onOpen();
    } else
      modal.onOpen();
    return;
  }
  Console.log("result has content");
  if (sectionContent.trim() === result.trim()) {
    Console.log("same content");
    return;
  } else {
    Console.log("not same content");
    if (!sectionContent) {
      Console.log("append");
      const added = content ? "\n# " + pluginItem.name + "\n\n" + result : "\n" + result;
      modal.app.vault.append(note, result);
    } else {
      Console.log("replace");
      const updatedContent = content.replace(sectionContent, result);
      await modal.app.vault.modify(note, updatedContent);
    }
    pluginItem.hasNote = true;
    await modal.plugin.saveSettings();
    if (_this) {
      _this.onOpen();
      modal.onOpen();
    } else
      modal.onOpen();
  }
}

// src/secondary_modals.ts
var DescriptionModal = class extends import_obsidian6.Modal {
  constructor(app, plugin, pluginItem) {
    super(app);
    this.plugin = plugin;
    this.pluginItem = pluginItem;
    this.plugin = plugin;
    this.pluginItem = pluginItem;
  }
  onOpen() {
    const { contentEl, pluginItem } = this;
    contentEl.empty();
    contentEl.createEl("p", {
      text: pluginItem.name + " - v" + pluginItem.version
    }).createEl("p", {
      text: "author: " + pluginItem.author + ", url: " + (pluginItem.authorUrl ? "" : "null")
    }).createEl("a", {
      text: pluginItem.authorUrl,
      href: pluginItem.authorUrl
    });
    contentEl.createEl("p", { text: pluginItem.description });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmModal = class extends import_obsidian6.Modal {
  constructor(app, message, callback, width, height) {
    super(app);
    this.message = message;
    this.callback = callback;
    this.width = width;
    this.height = height;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.width) {
      this.modalEl.style.width = `${this.width}px`;
    }
    if (this.height) {
      this.modalEl.style.height = `${this.height}px`;
    }
    contentEl.createEl("p").setText(this.message);
    new import_obsidian6.Setting(this.contentEl).addButton((b) => {
      b.setIcon("checkmark").setCta().onClick(() => {
        this.callback(true);
        this.close();
      });
    }).addExtraButton(
      (b) => b.setIcon("cross").onClick(() => {
        this.callback(false);
        this.close();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
async function openConfirmModal(app, message, width, height) {
  return await new Promise((resolve) => {
    new ConfirmModal(
      app,
      message,
      (confirmed) => {
        resolve(confirmed);
      },
      width != null ? width : void 0,
      height != null ? height : void 0
    ).open();
  });
}
async function confirm(message, width, height) {
  return await openConfirmModal(
    this.app,
    message,
    width != null ? width : void 0,
    height != null ? height : void 0
  );
}
var ReadMeModal = class extends import_obsidian6.Modal {
  constructor(app, modal, pluginItem) {
    super(app);
    this.modal = modal;
    this.pluginItem = pluginItem;
    this.scope = new import_obsidian6.Scope(this.app.scope);
    this.modal = modal;
    this.pluginItem = pluginItem;
    this.modalEl.addClass("read-me-modal");
    this.comp = new import_obsidian6.Component();
    this.comp.load();
  }
  async onOpen() {
    const { contentEl, pluginItem } = this;
    contentEl.empty();
    const id = pluginItem.id;
    contentEl.createEl("p", {
      text: pluginItem.name,
      cls: "readme-title"
    }).createEl("p", {
      text: "By: " + pluginItem.author
    });
    const openRepo = contentEl.createDiv();
    new import_obsidian6.ButtonComponent(openRepo).setButtonText("GitHub Repo").onClick(async (e) => {
      await openGitHubRepo(e, this.modal, pluginItem);
    });
    const divButtons = contentEl.createDiv({ cls: "read-me-buttons" });
    if (!isInstalled(id)) {
      new import_obsidian6.ButtonComponent(divButtons).setButtonText("Install").setCta().onClick(async () => {
        const manifest = await getManifest(this.modal, id);
        if (!manifest) {
          new import_obsidian6.Notice(`Manifest ${id} not found`, 2500);
          return;
        }
        const lastVersion = manifest.version;
        await this.app.plugins.installPlugin(pluginItem.repo, lastVersion != null ? lastVersion : "", manifest);
        new import_obsidian6.Notice(`${pluginItem.name} installed`, 2500);
        await this.onOpen();
        await reOpenModal(this.modal);
      });
    } else {
      const manifests = this.app.plugins.manifests || {};
      let condition2;
      if (!isEnabled(this.modal, manifests[pluginItem.id].id)) {
        new import_obsidian6.ButtonComponent(divButtons).setButtonText("Enable").onClick(async () => {
          await this.modal.app.plugins.enablePluginAndSave(pluginItem.id);
          await this.onOpen();
          this.modal.plugin.installedUpdate();
          new import_obsidian6.Notice(`${pluginItem.name} enabled`, 2500);
          await reOpenModal(this.modal);
        });
      } else {
        const pluginSettings = this.modal.app.setting.openTabById(pluginItem.id);
        if (pluginSettings) {
          new import_obsidian6.ButtonComponent(divButtons).setButtonText("Options").onClick(async (e) => {
            await openPluginSettings(
              e,
              this.modal,
              pluginItem
            );
          });
        }
        condition2 = await getHkeyCondition(this.modal, pluginItem);
        if (condition2) {
          new import_obsidian6.ButtonComponent(divButtons).setButtonText("Hotkeys").onClick(async (e) => {
            await showHotkeysFor(e, this.modal, pluginItem);
          });
        }
        if (id !== "quick-plugin-switcher")
          new import_obsidian6.ButtonComponent(divButtons).setButtonText("Disable").onClick(async () => {
            await this.modal.app.plugins.disablePluginAndSave(pluginItem.id);
            await this.onOpen();
            new import_obsidian6.Notice(`${pluginItem.name} disabled`, 2500);
            await reOpenModal(this.modal);
          });
      }
      if (id !== "quick-plugin-switcher")
        new import_obsidian6.ButtonComponent(divButtons).setButtonText("Uninstall").onClick(async () => {
          await this.modal.app.plugins.uninstallPlugin(
            pluginItem.id
          );
          await this.onOpen();
          new import_obsidian6.Notice(`${pluginItem.name} uninstalled`, 2500);
          await reOpenModal(this.modal);
        });
    }
    const shortcuts = contentEl.createDiv(
      {
        cls: "read-me-shortcuts"
      }
    );
    const notesButtonContainer = shortcuts.createDiv({ cls: "notes-button-container" });
    const notesButton2 = new import_obsidian6.ButtonComponent(notesButtonContainer).setButtonText("\u{1F4DD}").onClick(async (e) => {
      await handleNote(e, this.modal, pluginItem, this);
    });
    if (pluginItem.hasNote) {
      notesButtonContainer.addClass("notes-button-background");
    }
    if (import_obsidian6.Platform.isDesktop) {
      shortcuts.createSpan({
        text: " (t) translate  (n) add note"
      });
    }
    const div = contentEl.createDiv({ cls: "qps-read-me" });
    const data = await getReadMe(pluginItem);
    if (!data) {
      return;
    }
    const decoder = new TextDecoder("utf-8");
    const content = decoder.decode(base64ToUint8Array(data.content));
    const updatedContent = modifyGitHubLinks(content, pluginItem);
    await import_obsidian6.MarkdownRenderer.render(this.app, updatedContent, div, "/", this.comp);
    this.modalEl.addEventListener("mousemove", (event) => {
      this.mousePosition = { x: event.clientX, y: event.clientY };
    });
    this.scope.register([], "t", async () => {
      const selectedContent = getSelectedContent();
      if (!selectedContent) {
        new import_obsidian6.Notice("no selection", 4e3);
        return;
      }
      await translation(selectedContent);
    });
    this.scope.register([], "n", async (e) => await handleNote(e, this.modal, pluginItem));
    this.scope.register([], "escape", async (event) => {
      this.close();
    });
    this.modalEl.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      const selectedContent = getSelectedContent();
      if (selectedContent) {
        const menu = new import_obsidian6.Menu();
        menu.addItem(
          (item) => item.setTitle("Copy (Ctrl+C)").onClick(async () => {
            await navigator.clipboard.writeText(selectedContent);
          })
        );
        menu.addItem(
          (item) => item.setTitle("translate (t)").onClick(async () => {
            await translation(selectedContent);
          })
        );
        menu.showAtPosition(this.mousePosition);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.comp.unload();
  }
};
var SeeNoteModal = class extends import_obsidian6.Modal {
  constructor(app, modal, pluginItem, sectionContent, cb2, _this) {
    super(app);
    this.modal = modal;
    this.pluginItem = pluginItem;
    this.sectionContent = sectionContent;
    this.cb = cb2;
    this._this = _this;
  }
  onOpen() {
    const { contentEl: El } = this;
    El.createEl("h6", { text: "DON'T INCLUDE H1 titles. To delete a note delete all content.", cls: "read-me-shortcuts " });
    El.createEl("h3", { text: this.pluginItem.name + " by " + this.pluginItem.author });
    new import_obsidian6.Setting(El).addTextArea((text) => {
      var _a;
      text.setValue((_a = this.sectionContent) != null ? _a : "");
      text.inputEl.rows = 40;
      text.inputEl.cols = 82;
      text.inputEl.onblur = async () => {
        this.sectionContent = text.getValue();
        const lines = this.sectionContent.split("\n");
        let stop = false;
        for (const line of lines) {
          if (line.startsWith("# ")) {
            new import_obsidian6.Notice("H1 are not allowed, content was paste in clipboard", 4e3);
            const clipboard = navigator.clipboard.writeText(this.sectionContent);
            await this.cb(null);
            stop = true;
            break;
          }
        }
        this.onClose();
        if (stop)
          return;
        if (this.sectionContent && !this.sectionContent.endsWith("\n")) {
          this.sectionContent = this.sectionContent + "\n";
        }
        this.sectionContent;
        await this.cb(this.sectionContent);
      };
    });
  }
};

// src/modal_components.ts
var import_obsidian7 = require("obsidian");
var path2 = __toESM(require("path"));
var import_fs2 = require("fs");
var import_slug = __toESM(require_slug());
var mostSwitchedResetButton = (modal, contentEl) => {
  const { settings } = modal.plugin;
  const { filters, installed } = settings;
  if (filters === Filters.mostSwitched && Object.keys(installed).some(
    (id) => installed[id].switched !== 0
  )) {
    new import_obsidian7.ExtraButtonComponent(contentEl).setIcon("reset").setTooltip("Reset mostSwitched values").onClick(async () => {
      reset(modal);
      await reOpenModal(modal);
    });
  }
};
async function addSearch(modal, contentEl, placeholder) {
  const { plugin } = modal;
  const { settings } = plugin;
  new import_obsidian7.Setting(contentEl).addSearch(async (search) => {
    search.setValue(settings.search).setPlaceholder(placeholder).onChange((0, import_obsidian7.debounce)(async (value) => {
      if (modal.searchTyping) {
        settings.search = value;
        modal.items.empty();
        modal.addItems(value);
      }
    }, 20));
  }).setClass("qps-search-component");
}
function doSearchQPS(modal, value, plugins) {
  const lowerCaseValue = value.toLowerCase();
  const { byAuthor } = modal.plugin.settings;
  return Object.keys(plugins).filter((id) => {
    const { name, author } = plugins[id];
    const list = byAuthor ? [name, author] : [name];
    return list.some((prop) => prop.toLowerCase().includes(lowerCaseValue));
  });
}
function doSearchCPM(value, commPlugins) {
  const lowerCaseValue = value.toLowerCase();
  const pluginsList = Object.keys(commPlugins);
  return pluginsList.filter(
    (item) => [commPlugins[item].name, commPlugins[item].description, commPlugins[item].author].some((prop) => prop.toLowerCase().includes(lowerCaseValue))
  );
}
var getFilters = (modal, contentEl) => {
  const { plugin } = modal;
  const { settings } = plugin;
  new import_obsidian7.ButtonComponent(contentEl).setIcon("arrow-up-narrow-wide").setClass("comm-button").setTooltip(
    "change type of sorting"
  ).buttonEl.addEventListener("click", async (evt) => {
    const menu = new import_obsidian7.Menu();
    for (const key in SortBy) {
      menu.addItem(
        (item) => item.setTitle(SortBy[key]).onClick(async () => {
          settings.sortBy = key;
          await reOpenModal(modal);
        }).setChecked(key === settings.sortBy)
      );
    }
    menu.showAtMouseEvent(evt);
  });
};
var Check4UpdatesButton = (modal, el) => {
  const { plugin } = modal;
  const button = new import_obsidian7.ButtonComponent(el).setIcon("rocket").setCta();
  const toUpdate = Object.values(modal.plugin.settings.installed).filter((item) => item["toUpdate"]);
  if (toUpdate.length)
    button.setClass("red");
  button.setClass("update-button").setTooltip(
    "Search for updates"
  ).buttonEl.addEventListener("click", async (evt) => {
    if (toUpdate.length) {
      const menu = new import_obsidian7.Menu();
      menu.addItem(
        (item) => item.setTitle("Update plugin(s)").setIcon("book-copy").onClick(async () => {
          await Promise.allSettled(toUpdate.map(async (item2) => {
            item2["toUpdate"] = false;
            await updatePlugin(modal, item2, plugin.settings.commPlugins);
          }));
        })
      );
      menu.addItem(
        (item) => item.setTitle("Search for updates again").setIcon("rocket").onClick(async () => {
          searchUpdates(modal);
        })
      );
      menu.showAtMouseEvent(evt);
    } else {
      searchUpdates(modal);
    }
  });
};
var checkbox = (modal, contentEl, text) => {
  const { plugin } = modal;
  const { settings } = plugin;
  if (modal instanceof QPSModal && settings.filters === Filters.byGroup)
    return;
  const isQPS = modal instanceof QPSModal;
  contentEl.createDiv({ text, cls: "qps-comm-invert" }, (el) => {
    el.createEl(
      "input",
      {
        attr: {
          cls: "qps-invert-button",
          type: "checkbox",
          checked: isQPS ? settings.byAuthor : settings.invertFiltersComm
        }
      },
      (checkbox2) => {
        checkbox2.checked = isQPS ? settings.byAuthor : settings.invertFiltersComm, checkbox2.onchange = () => {
          isQPS ? settings.byAuthor = checkbox2.checked : settings.invertFiltersComm = checkbox2.checked;
          plugin.saveSettings();
          reOpenModal(modal);
        };
      }
    );
  });
};
async function searchUpdates(modal) {
  const { installed, commPlugins } = modal.plugin.settings;
  let open = false;
  let count = 0;
  for (const item of Object.values(installed)) {
    if (!item.dir)
      continue;
    const filePath = modal.app.vault.adapter.getFullPath(
      item.dir
    );
    if (!filePath)
      continue;
    if (import_obsidian7.Platform.isDesktop) {
      const isDevPath = path2.join(
        filePath,
        "package.json"
      );
      if ((0, import_fs2.existsSync)(isDevPath)) {
        continue;
      }
    }
    const manifest = await getManifest(modal, item.id);
    if (!manifest)
      continue;
    const lastVersion = manifest.version;
    if (!lastVersion || lastVersion <= item.version) {
      item["toUpdate"] = false;
      if (lastVersion && lastVersion <= item.version)
        open = true;
    } else {
      if (lastVersion > item.version) {
        count += 1;
        open = true;
        item["toUpdate"] = true;
      }
    }
  }
  if (open) {
    new import_obsidian7.Notice(`${count} plugins to update`, 3e3);
    await reOpenModal(modal);
  } else {
    new import_obsidian7.Notice("All plugins are up to date");
  }
}
var vertDotsButton = (el) => {
  new import_obsidian7.ButtonComponent(el).setButtonText("\u2807").setTooltip(
    "open context-menu"
  );
};
var notesButton = (el, modal, pluginItem) => {
  new import_obsidian7.ButtonComponent(el).setTooltip("open plugin notes").setButtonText("\u{1F4DD}");
};
var commButton = (modal, el) => {
  const { plugin } = modal;
  new import_obsidian7.ButtonComponent(el).setIcon("download-cloud").setCta().setClass("comm-button").setTooltip(
    "community plugins: you can tag plugins with groups, install by group..."
  ).buttonEl.addEventListener("click", async (evt) => {
    await plugin.exeAfterDelay(plugin.pluginsCommInfo.bind(plugin));
    modal.close();
    new CPModal(modal.app, plugin).open();
    focusSearchInput(10);
  });
};
var commOptionButton = (modal, el) => {
  const { plugin } = modal;
  new import_obsidian7.ButtonComponent(el).setIcon("list-end").setCta().setTooltip(
    "Install & enable plugins based on another Vault content or from a JSON list"
  ).buttonEl.addEventListener("click", (evt) => {
    const menu = new import_obsidian7.Menu();
    menu.addItem(
      (item) => item.setTitle("Install plugins based on another Vault").setIcon("book-copy").onClick(async () => {
        await installPluginFromOtherVault(modal);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Install & enable plugins based on another Vault").setIcon("book-copy").onClick(async () => {
        await installPluginFromOtherVault(modal, true);
      })
    );
    menu.addSeparator();
    menu.addItem(
      (item) => item.setTitle("Save installed plugins list").setIcon("pen-square").onClick(async () => {
        await getPluginsList(modal, true);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Install & enable plugins from json list").setIcon("list").onClick(async () => {
        await installFromList(modal, true);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Install plugins from json list").setIcon("list").onClick(async () => {
        await installFromList(modal);
      })
    );
    menu.showAtMouseEvent(evt);
  });
};
var powerButton = (modal, el) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed } = settings;
  new import_obsidian7.ButtonComponent(el).setIcon("power").setCta().setTooltip(
    "toggle plugins: you can disable some plugins and enable them later"
  ).buttonEl.addEventListener("click", (evt) => {
    const menu = new import_obsidian7.Menu();
    if (plugin.lengthEnabled === 1 && settings.wasEnabled.length === 0) {
      menu.addItem((item) => item.setTitle("No enabled plugins"));
    } else {
      menu.addItem(
        (item) => item.setTitle(
          settings.wasEnabled.length > 0 ? "Enable previous disabled plugins" : "Disable all plugins"
        ).setIcon(
          settings.wasEnabled.length > 0 ? "power" : "power-off"
        ).onClick(async () => {
          if (plugin.lengthEnabled > 1) {
            for (const id in installed) {
              if (id === "quick-plugin-switcher")
                continue;
              if (installed[id].enabled)
                settings.wasEnabled.push(id);
              await modal.app.plugins.disablePluginAndSave(id);
              installed[id].enabled = false;
            }
            plugin.getLength();
            await reOpenModal(modal);
            new import_obsidian7.Notice("All plugins disabled", 2500);
          } else if (settings.wasEnabled.length > 0) {
            for (const i of settings.wasEnabled) {
              const toUpdate = Object.keys(installed).find(
                (id) => id === i
              );
              if (toUpdate) {
                await conditionalEnable(
                  modal,
                  toUpdate
                );
                installed[toUpdate].enabled = true;
              }
            }
            plugin.getLength();
            await reOpenModal(modal);
            settings.wasEnabled = [];
            new import_obsidian7.Notice("All plugins re-enabled", 2500);
            await modal.plugin.saveSettings();
          }
        })
      );
      if (settings.wasEnabled.length > 0) {
        menu.addItem(
          (item) => item.setTitle("Skip re-enable").setIcon("reset").onClick(async () => {
            const confirmReset = await confirm(
              "reset to disable",
              300
            );
            if (confirmReset) {
              settings.wasEnabled = [];
              await modal.plugin.saveSettings();
              new import_obsidian7.Notice("Done", 2500);
            } else {
              new import_obsidian7.Notice("Operation cancelled", 2500);
            }
          })
        );
      }
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle("Toggle enabled-plugins by group").setDisabled(true)
      );
      Object.keys(Groups).forEach((groupKey) => {
        if (groupKey === "SelectGroup")
          return;
        const groupValue = Groups[groupKey];
        const groupIndex = getIndexFromSelectedGroup(groupKey);
        const inGroup = Object.keys(installed).filter((id) => {
          return installed[id].groupInfo.groupIndices.indexOf(
            groupIndex
          ) !== -1;
        });
        let previousWasEnabled = inGroup.filter(
          (id) => installed[id].groupInfo.groupWasEnabled === true
        );
        if (inGroup.length > 0 && (inGroup.some((id) => installed[id].enabled === true) || previousWasEnabled.length > 0)) {
          menu.addItem(
            (item) => item.setTitle(
              previousWasEnabled.length > 0 ? `Re-enable ${groupValue}` : groupValue
            ).setIcon(
              previousWasEnabled.length > 0 ? "power" : "power-off"
            ).onClick(async () => {
              if (previousWasEnabled.length === 0) {
                const toDisable = inGroup.filter((id) => installed[id].enabled === true).map(async (id) => {
                  installed[id].groupInfo.groupWasEnabled = true;
                  await modal.app.plugins.disablePluginAndSave(id);
                  installed[id].enabled = false;
                });
                await Promise.all(toDisable);
                if (toDisable) {
                  plugin.getLength();
                  await reOpenModal(modal);
                  new import_obsidian7.Notice(
                    "All plugins disabled",
                    2500
                  );
                }
              } else {
                for (const id of previousWasEnabled) {
                  await conditionalEnable(modal, id);
                  installed[id].enabled = true;
                  installed[id].switched++;
                }
                previousWasEnabled.map((id) => {
                  installed[id].groupInfo.groupWasEnabled = false;
                });
                plugin.getLength();
                await reOpenModal(modal);
                new import_obsidian7.Notice(
                  "All plugins re-enabled",
                  2500
                );
              }
            })
          );
          if (previousWasEnabled.length > 0) {
            menu.addItem(
              (item) => item.setTitle("Skip re-enable").setIcon("reset").onClick(async () => {
                const confirmReset = await confirm(
                  "skip re-enable ?",
                  200
                );
                if (confirmReset) {
                  previousWasEnabled.map((id) => {
                    installed[id].groupInfo.groupWasEnabled = false;
                  });
                  await modal.plugin.saveSettings();
                  new import_obsidian7.Notice("Done", 2500);
                } else {
                  new import_obsidian7.Notice(
                    "Operation cancelled",
                    2500
                  );
                }
              })
            );
          }
        }
      });
    }
    menu.showAtMouseEvent(evt);
  });
};
var itemToggleClass = (modal, pluginItem, itemContainer) => {
  if (pluginItem.target === 0) {
    itemContainer.toggleClass("qps-is-desktop", true);
  }
  if (pluginItem.target === 1) {
    itemContainer.toggleClass("qps-is-mobile", true);
  }
  const { settings } = modal.plugin;
  if (pluginItem.id === "quick-plugin-switcher") {
    itemContainer.toggleClass("qps-quick-plugin-switcher", true);
  }
  if (pluginItem.isDesktopOnly === true) {
    itemContainer.addClass("qps-desktop-only");
  }
  if (pluginItem.hasOwnProperty("toUpdate") && pluginItem.toUpdate === true) {
    itemContainer.toggleClass("qps-update", true);
  }
  if (settings.filters === Filters.mostSwitched && pluginItem.switched !== 0) {
    itemContainer.toggleClass("qps-most-switched", true);
  }
  if (pluginItem.delayed) {
    itemContainer.toggleClass("toggle-bullet-color", true);
    itemContainer.style.setProperty(
      "--bullet-content",
      `"${pluginItem.time}"`
    );
  }
};
var itemTextComponent = (pluginItem, itemContainer) => {
  let customValue = pluginItem.name;
  if (pluginItem.isDesktopOnly) {
    customValue = "\u1D30" + customValue;
  }
  customValue = customValue + `|${pluginItem.version}`;
  let text = new import_obsidian7.TextComponent(itemContainer).setValue(customValue);
  const input = text.inputEl;
  input.readOnly = true;
  return input;
};
var pluginFeatureSubmenu = async (evt, submenu, pluginItem, modal) => {
  const { settings } = modal.plugin;
  const { installed } = settings;
  const id = pluginItem.id;
  submenu.addItem(
    (item) => item.setTitle("Short info (i)").setIcon("text").onClick(() => {
      new DescriptionModal(
        modal.plugin.app,
        modal.plugin,
        installed[id]
      ).open();
    })
  );
  submenu.addItem(
    (item) => item.setTitle("Plugin github (g)").setIcon("github").onClick(async () => {
      await openGitHubRepo(evt, modal, installed[id]);
    })
  );
  const pluginSettings = modal.app.setting.openTabById(
    id
  );
  submenu.addItem(
    (item) => item.setTitle("Plugin settings (s)").setIcon("settings").setDisabled(!pluginSettings).onClick(async () => {
      await openPluginSettings(evt, modal, pluginItem);
    })
  );
  const condition2 = await getHkeyCondition(modal, pluginItem);
  submenu.addItem(
    (item) => item.setTitle("Modify hotkeys (h)").setIcon("plus-circle").setDisabled(!condition2).onClick(async () => {
      await showHotkeysFor(evt, modal, pluginItem);
    })
  );
};
var getHkeyCondition = async function(modal, item) {
  var _a, _b;
  const pluginCommands = await ((_b = (_a = modal.app.setting.openTabById(
    "command-palette"
  )) == null ? void 0 : _a.app) == null ? void 0 : _b.commands.commands);
  return hasKeyStartingWith(pluginCommands, item.id);
};
var openGitHubRepo = async (e, modal, plugin) => {
  var _a;
  let repo;
  if ("repo" in plugin) {
    repo = plugin.repo;
  } else {
    const key = plugin.id;
    const { commPlugins } = modal.plugin.settings;
    const matchingPlugin = Object.values(commPlugins).find(
      (plugin2) => plugin2.id === key
    );
    repo = (_a = matchingPlugin == null ? void 0 : matchingPlugin.repo) != null ? _a : "";
  }
  const repoURL = `https://github.com/${repo}`;
  window.open(repoURL, "_blank");
};
var searchDivButtons = (modal, contentEl) => {
  const span = contentEl.createEl(
    "span",
    {
      cls: "qps-toggle-plugins"
    },
    (el) => {
      powerButton(modal, el);
      commButton(modal, el);
      Check4UpdatesButton(modal, el);
    }
  );
};
function showStats(pluginItem) {
  const idSlug = (0, import_slug.default)(pluginItem.id);
  const URL2 = `https://www.moritzjung.dev/obsidian-stats/plugins/${idSlug}#plugin-download-chart`;
  window.open(URL2, "_blank");
}
var searchCommDivButton = (modal, contentEl) => {
  const span = contentEl.createEl(
    "span",
    {
      cls: "qps-toggle-plugins"
    },
    (el) => {
      commOptionButton(modal, el);
    }
  );
};
async function hideOnCLick(modal, groupNumber, inGroup) {
  var _a;
  const { plugin } = modal;
  const { settings } = plugin;
  const { groups, groupsComm, installed, commPlugins } = settings;
  if (modal instanceof QPSModal) {
    if (groups[groupNumber]) {
      if (!groups[groupNumber].hidden && !inGroup.length) {
        new import_obsidian7.Notice("empty group", 3e3);
        return;
      }
      groups[groupNumber].hidden = !groups[groupNumber].hidden;
    }
    inGroup.forEach((id) => {
      if (groups[groupNumber].hidden)
        installed[id].groupInfo.hidden = true;
      else {
        let prevent = false;
        for (const i of installed[id].groupInfo.groupIndices) {
          if (groups[i].hidden)
            prevent = true;
        }
        if (!prevent)
          installed[id].groupInfo.hidden = false;
      }
    });
  } else {
    if (groupsComm[groupNumber]) {
      if (!groupsComm[groupNumber].hidden && !inGroup.length) {
        new import_obsidian7.Notice("empty group", 3e3);
        return;
      }
      groupsComm[groupNumber].hidden = !((_a = groupsComm[groupNumber]) == null ? void 0 : _a.hidden);
    }
    inGroup.forEach((id) => {
      if (groupsComm[groupNumber].hidden)
        commPlugins[id].groupCommInfo.hidden = true;
      else {
        let prevent = false;
        for (const i of commPlugins[id].groupCommInfo.groupIndices) {
          if (groupsComm[i].hidden)
            prevent = true;
        }
        if (!prevent) {
          commPlugins[id].groupCommInfo.hidden = false;
        }
      }
    });
  }
  await reOpenModal(modal);
}
async function handleClick(evt, modal) {
  var _a;
  const elementFromPoint = (_a = getElementFromMousePosition(modal)) == null ? void 0 : _a.parentElement;
  if (elementFromPoint == null ? void 0 : elementFromPoint.classList.contains("button-container")) {
    const matchingItem = findMatchingItem(
      modal,
      elementFromPoint.parentElement
    );
    if (matchingItem) {
      if (modal instanceof QPSModal) {
        await contextMenuQPS(evt, modal, matchingItem);
      } else {
        contextMenuCPM(evt, modal, matchingItem);
      }
    }
  } else if (elementFromPoint == null ? void 0 : elementFromPoint.classList.contains("button-container1")) {
    const matchingItem = findMatchingItem(
      modal,
      elementFromPoint.parentElement
    );
    if (matchingItem && modal instanceof CPModal) {
      handleNote(evt, modal, matchingItem);
    }
  }
}
var touchCount = 0;
var touchDelay = 300;
var clickTimeout;
var element;
function handleTouchStart(evt, modal) {
  touchCount++;
  if (touchCount === 1) {
    element = evt.target;
    clickTimeout = setTimeout(() => {
      handleClick(evt, modal);
      touchCount = 0;
    }, touchDelay);
  }
  if (touchCount === 2) {
    handleDblClick(evt, modal, element);
    touchCount = 0;
    clearTimeout(clickTimeout);
  }
}
function handleDblClick(evt, modal, element2) {
  const elementFromPoint = element2 ? element2 : getElementFromMousePosition(modal);
  const targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-comm-block"
  );
  const targetGroup = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-groups-name"
  );
  const pluginItemBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-item-line input"
  );
  const targetGroupIcon = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-circle-title-group"
  );
  if (targetBlock) {
    const matchingItem = findMatchingItem(modal, targetBlock);
    if (!matchingItem)
      return;
    if (import_obsidian7.Platform.isMobile) {
      setTimeout(() => {
        new ReadMeModal(
          modal.plugin.app,
          modal,
          matchingItem
        ).open();
      }, 250);
    } else {
      new ReadMeModal(
        modal.plugin.app,
        modal,
        matchingItem
      ).open();
    }
  }
  if (pluginItemBlock) {
    const matchingItem = findMatchingItem(modal, pluginItemBlock);
    if (!matchingItem)
      return;
    handleInputDblClick(modal, pluginItemBlock, matchingItem);
  }
  if (targetGroup) {
    const groupName = targetGroup == null ? void 0 : targetGroup.textContent;
    const groupNumber = groupNbFromGrpName(groupName);
    editGroupName(modal, targetGroup, groupNumber);
  }
  if (targetGroupIcon && modal instanceof QPSModal) {
    const groupNumber = groupNbFromEmoticon(targetGroupIcon);
    const inGroup = getPluginsInGroup(modal, groupNumber);
    addDelayToGroup(modal, groupNumber, targetGroupIcon, inGroup);
  }
}
var handleInputDblClick = async (modal, itemContainer, pluginItem) => {
  if (pluginItem.id === "quick-plugin-switcher")
    return;
  const currentValue = pluginItem.time.toString();
  modal.isDblClick = true;
  if (!itemContainer) {
    return;
  }
  const input = createInput(itemContainer, currentValue);
  if (!pluginItem.delayed) {
    if (!input)
      return;
    const setDelay = () => {
      setTimeout(async () => {
        await modal.addDelay(pluginItem.id, input);
        modal.isDblClick = false;
      }, 100);
    };
    input.onkeydown = (event) => {
      if (event.key === "Enter") {
        setDelay();
      }
    };
    input.onblur = setDelay;
  } else {
    pluginItem.delayed = false;
    modal.isDblClick = false;
    if (!(pluginItem.target === 0 || pluginItem.target === 1)) {
      await modal.app.plugins.enablePluginAndSave(pluginItem.id);
    }
    await reOpenModal(modal);
  }
};
async function handleContextMenu(evt, modal) {
  const elementFromPoint = getElementFromMousePosition(modal);
  let targetBlock, targetGroup;
  targetGroup = elementFromPoint == null ? void 0 : elementFromPoint.closest(".qps-groups-name");
  const groupName = targetGroup == null ? void 0 : targetGroup.textContent;
  const groupNumber = groupNbFromGrpName(groupName);
  if (targetGroup) {
    await groupMenu(evt, modal, groupNumber, targetGroup);
    return;
  }
  if (modal instanceof QPSModal) {
    targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
      ".qps-item-line"
    );
  } else {
    targetBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
      ".qps-comm-block"
    );
  }
  if (targetBlock) {
    const matchingItem = findMatchingItem(modal, targetBlock);
    if (matchingItem) {
      if (modal instanceof QPSModal) {
        if (!modal.app.isMobile) {
          await contextMenuQPS(evt, modal, matchingItem);
        }
      } else {
        contextMenuCPM(evt, modal, matchingItem);
      }
    }
  }
}
function contextMenuCPM(evt, modal, matchingItem) {
  evt.preventDefault();
  const menu = new import_obsidian7.Menu();
  const { settings } = modal.plugin;
  const id = matchingItem.id;
  const selectedContent = getSelectedContent();
  if (selectedContent) {
    menu.addItem(
      (item) => item.setTitle("Copy").onClick(async () => {
        await navigator.clipboard.writeText(selectedContent);
      })
    );
    menu.addItem(
      (item) => item.setTitle("Translate (t)").onClick(async () => {
        await translation(selectedContent);
      })
    );
    menu.addSeparator();
  }
  if (import_obsidian7.Platform.isMobile) {
    menu.addItem((item) => {
      item.setTitle("View stats").setIcon("stats").onClick(async () => {
        showStats(matchingItem);
      });
    });
    menu.addSeparator();
  }
  menu.addItem((item) => {
    item.setTitle("Install plugin").setDisabled(isInstalled(id) || id === "quick-plugin-switcher").setIcon("log-in").onClick(async () => {
      const manifest = await getManifest(modal, id);
      if (!manifest) {
        new import_obsidian7.Notice(`Manifest ${id} not found`, 2500);
        return;
      }
      const lastVersion = manifest.version;
      await this.app.plugins.installPlugin(matchingItem.repo, lastVersion, manifest);
      await reOpenModal(modal);
    });
  });
  menu.addItem((item) => {
    const isenabled = isEnabled(modal, id);
    item.setTitle(isenabled ? "Disable plugin" : "Enable plugin").setDisabled(!isInstalled(id) || id === "quick-plugin-switcher").setIcon(isenabled ? "poweroff" : "power").onClick(async () => {
      isEnabled(modal, id) ? await modal.app.plugins.disablePluginAndSave(id) : await modal.app.plugins.enablePluginAndSave(id);
      const msg = isenabled ? "disabled" : "enabled";
      new import_obsidian7.Notice(`${matchingItem.name} ${msg}`, 2500);
      reOpenModal(modal);
    });
  });
  menu.addItem((item) => {
    item.setTitle("Uninstall plugin").setDisabled(!isInstalled(id) || id === "quick-plugin-switcher").setIcon("log-out").onClick(async () => {
      await this.app.plugins.uninstallPlugin(id);
      new import_obsidian7.Notice(`${matchingItem.name} uninstalled`, 2500);
      await reOpenModal(modal);
    });
  });
  if (this.app.isMobile) {
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Plugin github").setIcon("github").onClick(async (evt2) => {
        await openGitHubRepo(evt2, modal, matchingItem);
      });
    });
    menu.addItem(
      (item) => item.setTitle("open Readme (dbl touch)").setIcon("sticky-note").onClick(() => {
        new ReadMeModal(modal.app, modal, matchingItem).open();
      })
    );
    menu.addSeparator();
    addToGroupSubMenu(menu, matchingItem, modal, true);
    menu.addSeparator();
    addRemoveItemGroupMenuItems(modal, menu, matchingItem, true);
    menu.addItem((item) => {
      item.setTitle("Remove All groups").setDisabled(
        matchingItem.groupCommInfo.groupIndices.length === 0
      ).onClick(async () => {
        await rmvAllGroupsFromPlugin(modal, matchingItem);
      });
    });
  }
  if (evt instanceof MouseEvent) {
    menu.showAtMouseEvent(evt);
  } else {
    menu.showAtPosition(modal.mousePosition);
  }
}
async function contextMenuQPS(evt, modal, matchingItem) {
  const { plugin } = modal;
  const menu = new import_obsidian7.Menu();
  if (!this.app.isMobile) {
    menu.addItem(
      (item) => item.setTitle("Plugin folder (f)").setIcon("folder-open").onClick(async () => {
        await openDirectoryInFileManager(modal, matchingItem);
      })
    );
  }
  if (!this.app.isMobile) {
    menu.addItem(async (item) => {
      item.setTitle("Plugin features").setIcon("package-plus");
      const submenu = item.setSubmenu();
      await pluginFeatureSubmenu(evt, submenu, matchingItem, modal);
    });
  } else {
    await pluginFeatureSubmenu(evt, menu, matchingItem, modal);
  }
  menu.addSeparator();
  menu.addItem((item) => {
    if (import_obsidian7.Platform.isDesktop) {
      const text = matchingItem.target !== void 0 ? `run on ${TargetPlatform[matchingItem.target]}` : "run on Both";
      item.setTitle(text);
    }
    const submenu = import_obsidian7.Platform.isMobile ? menu : item.setSubmenu();
    Object.keys(TargetPlatform).filter((key) => isNaN(Number(key))).forEach((key) => {
      let text = key;
      if (import_obsidian7.Platform.isMobile) {
        text = `run on ${key}`;
      }
      submenu.addItem((sub) => {
        sub.setTitle(text).onClick(async () => {
          const target = TargetPlatform[key];
          if (matchingItem.isDesktopOnly && target === 1 /* Mobile */) {
            new import_obsidian7.Notice("Plugin is only for desktop", 2500);
            return;
          }
          matchingItem.target = target;
          if (matchingItem.commandified) {
            await removeCommandFromPlugin(modal, matchingItem);
            await addCommandToPlugin(modal, matchingItem);
          }
          if (matchingItem.enabled) {
            if (target === 1 /* Mobile */ && import_obsidian7.Platform.isDesktop || target === 0 /* Desktop */ && import_obsidian7.Platform.isMobile) {
              await this.app.plugins.disablePluginAndSave(matchingItem.id);
            } else if ((target === 1 /* Mobile */ && import_obsidian7.Platform.isMobile || target === 0 /* Desktop */ && import_obsidian7.Platform.isDesktop) && !matchingItem.delayed) {
              await delayedReEnable(modal, matchingItem.id);
            } else if (target === 2 /* Both */ && !matchingItem.delayed) {
              await this.app.plugins.enablePluginAndSave(matchingItem.id);
            }
          }
          await reOpenModal(modal);
        });
      });
    });
  });
  if (isInstalled(matchingItem.id)) {
    menu.addSeparator();
    menu.addItem((item) => {
      let disabled = false;
      disabled = matchingItem.id === "quick-plugin-switcher";
      if (!matchingItem.dir) {
        disabled = true;
      }
      const filePath = modal.app.vault.adapter.getFullPath(
        matchingItem.dir
      );
      if (!filePath)
        disabled = true;
      if (import_obsidian7.Platform.isDesktop) {
        const isDevPath = path2.join(
          filePath,
          "package.json"
        );
        if ((0, import_fs2.existsSync)(isDevPath)) {
          disabled = true;
        }
      }
      const { commPlugins } = plugin.settings;
      item.setTitle("Update plugin!").setDisabled(disabled).setIcon("rocket").onClick(async () => {
        await updatePlugin(modal, matchingItem, commPlugins);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Uninstall plugin").setDisabled(matchingItem.id === "quick-plugin-switcher").setIcon("log-out").onClick(async () => {
        await this.app.plugins.uninstallPlugin(matchingItem.id);
        new import_obsidian7.Notice(`${matchingItem.name} uninstalled`, 2500);
        await modal.plugin.installedUpdate();
        await reOpenModal(modal);
      });
    });
    if (import_obsidian7.Platform.isDesktop) {
      const text = matchingItem.commandified ? "Remove command from plugin" : "Add command to plugin";
      const disabled = import_obsidian7.Platform.isDesktop && matchingItem.target === 1 /* Mobile */ || import_obsidian7.Platform.isMobile && matchingItem.target === 0 /* Desktop */;
      menu.addItem((item) => {
        item.setTitle(text).setIcon("arrow-right-left").setDisabled(disabled).onClick(async () => {
          if (matchingItem.commandified) {
            delete matchingItem.commandified;
            await removeCommandFromPlugin(modal, matchingItem);
            await plugin.saveSettings();
          } else {
            matchingItem.commandified = true;
            await addCommandToPlugin(modal, matchingItem);
          }
          await plugin.saveSettings();
        });
      });
    }
  }
  if (matchingItem.id !== "quick-plugin-switcher") {
    menu.addSeparator();
    if (!this.app.isMobile) {
      menu.addItem((item) => {
        item.setTitle("Add to group").setIcon("user");
        const submenu = item.setSubmenu();
        addToGroupSubMenu(submenu, matchingItem, modal);
      });
    } else {
      addToGroupSubMenu(menu, matchingItem, modal, true);
    }
    if (!this.app.isMobile) {
      menu.addItem((item) => {
        item.setTitle("Remove from group").setIcon("user-minus");
        const submenu = item.setSubmenu();
        submenu.addItem((subitem) => {
          subitem.setTitle("All groups").setDisabled(
            matchingItem.groupInfo.groupIndices.length === 0
          ).onClick(async () => {
            await rmvAllGroupsFromPlugin(modal, matchingItem);
          });
        });
        addRemoveItemGroupMenuItems(modal, submenu, matchingItem);
      });
    } else {
      menu.addSeparator();
      addRemoveItemGroupMenuItems(modal, menu, matchingItem, true);
      menu.addItem((item) => {
        item.setTitle("Remove All groups").setDisabled(
          matchingItem.groupInfo.groupIndices.length === 0
        ).onClick(async () => {
          await rmvAllGroupsFromPlugin(modal, matchingItem);
        });
      });
    }
  }
  if (evt instanceof MouseEvent) {
    menu.showAtMouseEvent(evt);
  } else {
    menu.showAtPosition(modal.mousePosition);
  }
}
async function updatePlugin(modal, matchingItem, commPlugins) {
  const { id, version } = matchingItem;
  if (!matchingItem.dir) {
    new import_obsidian7.Notice(`Not a published plugin`, 2500);
    return;
  }
  const filePath = modal.app.vault.adapter.getFullPath(
    matchingItem.dir
  );
  if (!filePath)
    return;
  if (import_obsidian7.Platform.isDesktop) {
    const isDevPath = path2.join(
      filePath,
      "package.json"
    );
    if ((0, import_fs2.existsSync)(isDevPath)) {
      return;
    }
  }
  const manifest = await getManifest(modal, id);
  const hasRelease = await getReleaseVersion(modal, id, manifest);
  const lastVersion = manifest.version;
  if (!(id in commPlugins)) {
    new import_obsidian7.Notice(`Not a published plugin`, 2500);
  } else if (!manifest) {
    new import_obsidian7.Notice(`No manifest in ${commPlugins[id].repo}`, 3500);
  } else if (!hasRelease) {
    new import_obsidian7.Notice(`can't update, version ${manifest.version} in repo has not been released!`);
  } else if (lastVersion <= version) {
    new import_obsidian7.Notice(`Already last version ${lastVersion}`, 2500);
  } else {
    try {
      await modal.app.plugins.installPlugin(commPlugins[id].repo, lastVersion, manifest);
      new import_obsidian7.Notice(`version ${version} updated to ${lastVersion}`, 2500);
      matchingItem.version = lastVersion;
      await modal.plugin.installedUpdate();
    } catch (e) {
      console.error("install failed");
    }
  }
  matchingItem.toUpdate = false;
  await reOpenModal(modal);
}
var findMatchingItem = (modal, targetBlock) => {
  const { installed, commPlugins } = modal.plugin.settings;
  if (modal instanceof QPSModal) {
    let itemName = targetBlock.children[1] ? targetBlock.children[1].value : targetBlock.value;
    if (itemName.startsWith("\u1D30")) {
      itemName = itemName.substring(1);
    }
    itemName = itemName.split("|")[0];
    const matchingItem = Object.keys(installed).find(
      (id) => installed[id].name === itemName
    );
    return installed[matchingItem];
  } else {
    let itemNameElement;
    for (let i = 0; i < targetBlock.children.length; i++) {
      if (targetBlock.children[i].classList.contains("qps-community-item-name")) {
        itemNameElement = targetBlock.children[i];
        break;
      }
    }
    const itemName = itemNameElement == null ? void 0 : itemNameElement.textContent;
    const cleanItemName = itemName == null ? void 0 : itemName.replace(/installed$/, "").trim();
    const matchingItem = Object.keys(commPlugins).find(
      (id) => commPlugins[id].name === cleanItemName
    );
    return commPlugins[matchingItem];
  }
};
var createClearGroupsMenuItem = (modal, menu, groupNumber) => {
  if (!modal.app.isMobile) {
    menu.addItem((item) => {
      item.setTitle("Clear group(s)").setIcon("user-minus");
      const submenu = item.setSubmenu();
      addRemoveGroupMenuItems(modal, submenu, groupNumber);
      submenu.addSeparator();
      clearAllGroups(submenu, modal);
    });
  } else {
    menu.addItem((item) => {
      item.setTitle("Clear group(s)").setIcon("user-minus");
    });
    addRemoveGroupMenuItems(modal, menu, groupNumber);
    clearAllGroups(menu, modal);
  }
};
function clearAllGroups(submenu, modal) {
  const { plugin } = modal;
  const { settings } = plugin;
  const { installed, commPlugins, groups, groupsComm } = settings;
  submenu.addItem((subitem) => {
    subitem.setTitle("All groups").onClick(async () => {
      const confirmReset = await confirm(
        "Detach all groups from all plugins?",
        300
      );
      if (confirmReset) {
        if (modal instanceof QPSModal) {
          for (const id in installed) {
            installed[id].groupInfo.hidden = false;
            installed[id].groupInfo.groupIndices = [];
          }
          for (const group in groups)
            groups[group].hidden = false;
          await reOpenModal(modal);
          new import_obsidian7.Notice(`All groups empty`, 2500);
        } else {
          for (const group in groupsComm)
            groupsComm[group].hidden = false;
          for (const id in commPlugins) {
            commPlugins[id].groupCommInfo.hidden = false;
            commPlugins[id].groupCommInfo.groupIndices = [];
          }
          await reOpenModal(modal);
          new import_obsidian7.Notice(`All groups empty`, 2500);
        }
      } else {
        new import_obsidian7.Notice("Operation cancelled", 2500);
      }
    });
  });
}
async function addCommandToPlugin(modal, pluginItem) {
  const plugin = modal instanceof QPSModal ? modal.plugin : modal;
  if (!pluginItem.commandified)
    return;
  const disabled = import_obsidian7.Platform.isDesktop && pluginItem.target === 1 /* Mobile */ || import_obsidian7.Platform.isMobile && pluginItem.target === 0 /* Desktop */;
  plugin.addCommand({
    id: pluginItem.id + "-switcher",
    name: "\u21D4 switch " + pluginItem.name.toLocaleLowerCase(),
    callback: async () => {
      const isLoaded = modal.app.plugins.getPlugin(pluginItem.id);
      if (disabled) {
        new import_obsidian7.Notice(`${pluginItem.name} not available on this platform`, 2500);
        return;
      }
      if (isLoaded) {
        new import_obsidian7.Notice(`${pluginItem.name} disabled`, 2500);
        modal.app.plugins.disablePlugin(pluginItem.id);
      } else {
        new import_obsidian7.Notice(`${pluginItem.name} enabled`, 2500);
        modal.app.plugins.enablePlugin(pluginItem.id);
      }
    }
  });
}
async function removeCommandFromPlugin(modal, pluginItem) {
  const { plugin } = modal;
  const QPSname = modal.plugin.manifest.id + ":";
  const pluginId = pluginItem.id + "-switcher";
  modal.app.commands.removeCommand(QPSname + pluginId);
}

// src/main_modal.ts
var QPSModal = class extends import_obsidian8.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.searchTyping = true;
    this.isDblClick = false;
    this.pressed = false;
    this.searchInit = true;
    this.getMousePosition = (event) => {
      this.mousePosition = { x: event.clientX, y: event.clientY };
    };
    this.getHandleKeyDown = async (event) => {
      await handleKeyDown2(event, this);
    };
    this.getHandleContextMenu = async (evt) => {
      if (this.isDblClick)
        return;
      await handleContextMenu(evt, this);
    };
    this.getHandleDblClick = (evt) => {
      if (this.isDblClick)
        return;
      handleDblClick(evt, this);
    };
    this.getHandleClick = (evt) => {
      if (this.isDblClick)
        return;
      handleClick(evt, this);
    };
    this.getHandleTouch = (evt) => {
      if (this.isDblClick)
        return;
      handleTouchStart(evt, this);
    };
    this.addHeader = (contentEl) => {
      const { plugin } = this;
      const { settings } = plugin;
      new import_obsidian8.DropdownComponent(contentEl).addOptions({
        all: `All(${plugin.lengthAll})`,
        enabled: `Enabled(${plugin.lengthEnabled})`,
        disabled: `Disabled(${plugin.lengthDisabled})`,
        enabledFirst: `Enabled First(${plugin.lengthAll})`,
        mostSwitched: `Most Switched(${plugin.lengthAll})`,
        byGroup: `By Group`,
        hidden: `Hidden(${getHidden(this, Object.keys(settings.installed)).length})`
      }).setValue(settings.filters).onChange(async (value) => {
        settings.filters = value;
        await reOpenModal(this);
      });
      mostSwitchedResetButton(this, contentEl);
      byGroupDropdowns(this, contentEl);
    };
    this.addDelay = async (id, input) => {
      const { plugin } = this;
      const { settings } = plugin;
      const { installed } = settings;
      installed[id].delayed = true;
      installed[id].time = parseInt(input.value) || 0;
      if (installed[id].time === 0) {
        installed[id].delayed = false;
      }
      if (installed[id].delayed && installed[id].enabled) {
        await delayedReEnable(this, id);
      }
      await reOpenModal(this);
    };
    this.plugin = plugin;
  }
  removeListeners() {
    this.modalEl.removeEventListener("mousemove", this.getMousePosition);
    document.removeEventListener("keydown", this.getHandleKeyDown);
    this.modalEl.removeEventListener("contextmenu", this.getHandleContextMenu);
    if (import_obsidian8.Platform.isDesktop) {
      this.modalEl.removeEventListener("dblclick", this.getHandleDblClick);
      this.modalEl.removeEventListener("click", this.getHandleClick);
    }
    if (import_obsidian8.Platform.isMobile) {
      this.modalEl.removeEventListener("touchstart", this.getHandleTouch);
    }
  }
  container() {
    const { contentEl } = this;
    this.modalEl.addClass("qps-modal");
    this.header = contentEl.createEl("div", {
      cls: "qps-header"
    });
    this.search = contentEl.createEl("div", { cls: "qps-search" });
    this.groups = contentEl.createEl("div", { cls: "qps-groups" });
    this.hotkeysDesc = contentEl.createEl("p", { cls: "qps-hk-desc" });
    this.items = contentEl.createEl("div", { cls: "qps-items" });
    this.modalEl.addEventListener("mousemove", this.getMousePosition);
    document.addEventListener("keydown", this.getHandleKeyDown);
    this.modalEl.addEventListener("contextmenu", this.getHandleContextMenu);
    if (import_obsidian8.Platform.isDesktop) {
      this.modalEl.addEventListener("dblclick", this.getHandleDblClick);
      this.modalEl.addEventListener("click", this.getHandleClick);
    }
    if (import_obsidian8.Platform.isMobile) {
      this.modalEl.addEventListener("touchstart", this.getHandleTouch);
    }
  }
  async onOpen() {
    this.removeListeners();
    const { plugin, contentEl } = this;
    const { settings } = plugin;
    if (this.searchInit)
      settings.search = "";
    this.searchInit = true;
    contentEl.empty();
    this.container();
    setGroupTitle(this, Groups, settings.numberOfGroups);
    this.addHeader(this.header);
    await addSearch(this, this.search, "Search plugins");
    checkbox(this, this.search, "Author");
    searchDivButtons(this, this.search);
    this.addGroups(this.groups);
    if (settings.showHotKeys && !this.app.isMobile)
      this.setHotKeysdesc();
    await this.addItems(settings.search);
  }
  addGroups(contentEl) {
    const groups = Object.values(Groups);
    for (let i = 1; i < groups.length; i++) {
      const groupKey = groups[i];
      contentEl.createEl(
        "span",
        {
          cls: "qps-group-span-container"
        },
        (cont) => {
          cont.createEl(
            "span",
            {
              cls: "qps-circle-title-group"
            },
            (el) => {
              circleCSSModif(this, el, i);
            }
          );
          const span = cont.createEl("span", {
            cls: "qps-groups-name",
            text: `${groupKey}`
          }, (el) => {
            var _a;
            const { plugin } = this;
            const { settings } = plugin;
            const hidden = (_a = settings.groups[i]) == null ? void 0 : _a.hidden;
            if (hidden) {
              el.style.textDecoration = "line-through";
              el.style.opacity = "0.6";
            } else {
              el.style.textDecoration = "none";
            }
          });
          const groupNumberText = `(<span class="shortcut-number">${i}</span>)`;
          span.insertAdjacentHTML("beforeend", groupNumberText);
        }
      );
    }
    if (!this.app.isMobile) {
      contentEl.createSpan({
        text: `> (h)\u{1F441}\uFE0F (\u{1F5B1}\uFE0Fx2)name`
      });
    } else {
      contentEl.createSpan({
        text: `(\u{1F5B1}\uFE0Fx2)name,icon:delay (\u{1F5B1}\uFE0F...)context-menu`
      });
    }
  }
  setHotKeysdesc() {
    const numberOfGroups = this.plugin.settings.numberOfGroups;
    this.hotkeysDesc.createSpan(
      {
        text: `(1-${numberOfGroups})\u2795 (0)\u274C (f)\u{1F4C1} `
      },
      (el) => {
        el.createSpan({ text: "(g)" }, (el2) => {
          let gitHubIcon = el2.createSpan({ cls: "git-hub-icon" });
          (0, import_obsidian8.setIcon)(gitHubIcon, "github");
        });
        el.createSpan({
          text: ` (ctrl)\u2139\uFE0F (s)\u2699\uFE0F (h)\u2328\uFE0F `
        });
        el.createSpan({
          cls: "qps-hk-desc-last-part",
          text: `(\u{1F5B1}\uFE0Fx2)delay`
        });
      }
    );
  }
  async addItems(value) {
    const { plugin } = this;
    const { settings } = plugin;
    const { installed, filters } = settings;
    let listItems = doSearchQPS(this, value, installed);
    listItems = modeSort(this, plugin, listItems);
    for (const id of listItems) {
      if (filters !== Filters.byGroup && installed[id].groupInfo.hidden === true && filters !== Filters.hidden) {
        continue;
      }
      if (filters === Filters.enabled && !installed[id].enabled || filters === Filters.disabled && installed[id].enabled) {
        continue;
      }
      let itemContainer = this.items.createEl("div", {
        cls: "qps-item-line"
      });
      itemTogglePluginButton(this, installed[id], itemContainer);
      const input = itemTextComponent(installed[id], itemContainer);
      itemToggleClass(this, installed[id], itemContainer);
      addGroupCircles2(input, installed[id]);
      if (this.app.isMobile) {
        const div = itemContainer.createEl(
          "div",
          {
            cls: "button-container"
          },
          (el) => {
            vertDotsButton(el);
          }
        );
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.removeListeners();
  }
};
function circleCSSModif(modal, el, groupIndex) {
  var _a;
  const { color } = getEmojiForGroup(groupIndex);
  el.style.backgroundColor = color;
  if (modal instanceof QPSModal) {
    const { settings } = modal.plugin;
    el.textContent = (((_a = settings.groups[groupIndex]) == null ? void 0 : _a.time) ? settings.groups[groupIndex].time : "").toString();
  }
}
var itemTogglePluginButton = (modal, pluginItem, itemContainer) => {
  var _a;
  const platformOff = pluginItem.target === 1 /* Mobile */ && import_obsidian8.Platform.isDesktop || pluginItem.target === 0 /* Desktop */ && import_obsidian8.Platform.isMobile;
  const desktopOnlyOff = pluginItem.isDesktopOnly && import_obsidian8.Platform.isMobile || platformOff;
  let disable = (_a = pluginItem.id === "quick-plugin-switcher" || desktopOnlyOff || platformOff) != null ? _a : false;
  const enabled = desktopOnlyOff ? false : pluginItem.enabled;
  new import_obsidian8.ToggleComponent(itemContainer).setValue(enabled).setDisabled(disable).onChange(async () => {
    await togglePlugin(modal, pluginItem);
  });
};
var addGroupCircles2 = (input, item) => {
  const indices = item.groupInfo.groupIndices;
  if (!indices.length)
    return;
  if (indices.length < 3) {
    const content = getCirclesItem(indices);
    input.insertAdjacentHTML("afterend", content);
  }
  if (indices.length >= 3 && indices.length < 5) {
    const [valeur0, valeur1, ...part2] = indices;
    const part1 = [valeur0, valeur1];
    const content1 = getCirclesItem(part1);
    input.insertAdjacentHTML("afterend", content1);
    const content2 = getCirclesItem(part2);
    input.insertAdjacentHTML("afterend", content2);
  } else if (indices.length >= 5) {
    const [valeur0, valeur1, valeur2, valeur3, ...part3] = indices;
    const part1 = [valeur0, valeur1];
    const part2 = [valeur2, valeur3];
    const content1 = getCirclesItem(part1);
    input.insertAdjacentHTML("afterend", content1);
    const content2 = getCirclesItem(part2);
    input.insertAdjacentHTML("afterend", content2);
    const content3 = getCirclesItem(part3);
    input.insertAdjacentHTML("afterend", content3);
  }
};
async function handleKeyDown2(event, modal) {
  var _a, _b;
  const elementFromPoint = getElementFromMousePosition(modal);
  const pluginItemBlock = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-item-line"
  );
  const targetGroupIcon = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-circle-title-group"
  );
  const targetGroup = elementFromPoint == null ? void 0 : elementFromPoint.closest(
    ".qps-groups-name"
  );
  if (pluginItemBlock) {
    (_a = document.querySelector(".qps-search-component input")) == null ? void 0 : _a.blur();
    modal.searchTyping = false;
    const matchingItem = findMatchingItem(modal, pluginItemBlock);
    if (matchingItem) {
      await handleHotkeysQPS(modal, event, matchingItem);
    }
  } else if ((targetGroupIcon || targetGroup) && event.key === "h") {
    (_b = document.querySelector(".qps-search-component input")) == null ? void 0 : _b.blur();
    modal.searchTyping = false;
    await toggleVisibility(modal, targetGroupIcon, targetGroup);
  } else {
    modal.searchTyping = true;
  }
}
var toggleVisibility = async (modal, targetGroupIcon, targetGroup) => {
  let groupNumber;
  if (targetGroupIcon) {
    groupNumber = groupNbFromEmoticon(targetGroupIcon);
  } else {
    const groupName = targetGroup == null ? void 0 : targetGroup.textContent;
    groupNumber = groupNbFromGrpName(groupName);
  }
  const inGroup = getPluginsInGroup(modal, groupNumber);
  await hideOnCLick(modal, groupNumber, inGroup);
};
var handleHotkeysQPS = async (modal, evt, pluginItem) => {
  const { plugin } = modal;
  const { settings } = plugin;
  const { groups, installed } = settings;
  const numberOfGroups = settings.numberOfGroups;
  const KeyToSettingsMap = {
    g: async () => await openGitHubRepo(evt, modal, pluginItem),
    s: async () => await openPluginSettings(evt, modal, pluginItem),
    h: async () => await showHotkeysFor(evt, modal, pluginItem)
  };
  if (import_obsidian8.Platform.isDesktopApp)
    KeyToSettingsMap["f"] = async () => await openDirectoryInFileManager(modal, pluginItem);
  const keyPressed = evt.key;
  if (!pluginItem.groupInfo) {
    pluginItem.groupInfo = {
      groupIndices: [],
      groupWasEnabled: false,
      hidden: false
    };
    await reOpenModal(modal);
  }
  if (modal.pressed) {
    return;
  }
  pressDelay(modal);
  if (modal.isDblClick)
    return;
  const groupIndices = pluginItem.groupInfo.groupIndices;
  const key = parseInt(keyPressed);
  if (key > 0 && key <= numberOfGroups && !(pluginItem.id === "quick-plugin-switcher")) {
    if (groupIndices.length === 6)
      return;
    const index = groupIndices.indexOf(key);
    if (index === -1) {
      groupIndices == null ? void 0 : groupIndices.push(key);
      if (groups[key].hidden)
        installed[pluginItem.id].groupInfo.hidden = true;
      await reOpenModal(modal);
    }
  } else if (keyPressed in KeyToSettingsMap) {
    KeyToSettingsMap[keyPressed]();
  } else if (evt.metaKey || evt.ctrlKey) {
    new DescriptionModal(plugin.app, plugin, pluginItem).open();
  } else if ((keyPressed === "Delete" || keyPressed === "Backspace" || keyPressed === "0") && !(pluginItem.id === "quick-plugin-switcher")) {
    if (!groupIndices.length)
      return;
    if (groupIndices.length === 1) {
      const groupIndex = groupIndices[0];
      pluginItem.groupInfo.groupIndices = [];
      if (groupIsEmpty(groupIndex, modal)) {
        settings.selectedGroup = "SelectGroup";
      }
      await reOpenModal(modal);
    } else {
      const menu = new import_obsidian8.Menu();
      menu.addItem(
        (item) => item.setTitle("Remove item group(s)").setDisabled(true).setDisabled(true)
      );
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle("All").onClick(async () => {
          await rmvAllGroupsFromPlugin(modal, pluginItem);
        })
      );
      for (const groupIndex of groupIndices) {
        const { emoji } = getEmojiForGroup(groupIndex);
        menu.addItem(
          (item) => item.setTitle(`${emoji} group ${groupIndex}`).onClick(async () => {
            pluginItem.groupInfo.groupIndices = removeItem(
              pluginItem.groupInfo.groupIndices,
              groupIndex
            );
            await reOpenModal(modal);
          })
        );
      }
      menu.showAtPosition(modal.mousePosition);
    }
  }
};

// src/settings.ts
var import_obsidian10 = require("obsidian");

// src/suggester.ts
var import_obsidian9 = require("obsidian");
var FolderSuggest = class extends import_obsidian9.AbstractInputSuggest {
  getSuggestions(query) {
    const result = [];
    for (const abstractFile of this.app.vault.getAllLoadedFiles()) {
      if (abstractFile instanceof import_obsidian9.TFolder && abstractFile.path.includes(query)) {
        result.push(abstractFile);
      }
    }
    return result;
  }
  renderSuggestion(value, el) {
    el.createEl("span", { text: value.path });
  }
  selectSuggestion(value) {
    this.textInputEl.value = value.path;
    this.textInputEl.trigger("input");
    this.close();
  }
};

// src/settings.ts
var QPSSettingTab = class extends import_obsidian10.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    const { plugin } = this;
    const { settings } = plugin;
    containerEl.empty();
    let saveSettingsTimeout;
    const { numberOfGroups, numberOfGroupsComm } = settings;
    new import_obsidian10.Setting(containerEl).setName("Number of plugins groups").setDesc("To treat plugins by groups").addSlider((slider) => {
      slider.setLimits(1, 6, 1).setValue(numberOfGroups).setDynamicTooltip().onChange(async (value) => {
        if (value < numberOfGroups) {
          clearTimeout(saveSettingsTimeout);
          saveSettingsTimeout = setTimeout(async () => {
            const confirmReset = await confirm(
              "reducing number of groups, higher groups info will be lost",
              350
            );
            if (confirmReset) {
              const { installed } = settings;
              for (const key in installed) {
                let hasValueGreaterThanValue = false;
                for (const groupIndex of installed[key].groupInfo.groupIndices) {
                  if (groupIndex > value) {
                    hasValueGreaterThanValue = true;
                    break;
                  }
                }
                if (hasValueGreaterThanValue) {
                  installed[key].groupInfo.groupIndices = [];
                }
              }
              settings.numberOfGroups = value;
              await plugin.saveSettings();
            } else {
              slider.setValue(numberOfGroups);
            }
          }, 700);
        } else {
          clearTimeout(saveSettingsTimeout);
          settings.numberOfGroups = value;
          await plugin.saveSettings();
        }
        settings.numberOfGroups = value;
        await plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(containerEl).setName("Number of community plugins groups").setDesc("To treat plugins by groups").addSlider((slider) => {
      slider.setLimits(1, 6, 1).setValue(numberOfGroupsComm).setDynamicTooltip().onChange(async (value) => {
        if (value < numberOfGroupsComm) {
          clearTimeout(saveSettingsTimeout);
          saveSettingsTimeout = setTimeout(async () => {
            const confirmReset = await confirm(
              "reducing number of groups, higher groups info will be lost",
              350
            );
            if (confirmReset) {
              const { commPlugins } = settings;
              for (const key in commPlugins) {
                let hasValueGreaterThanValue = false;
                let groupIndices = commPlugins[key].groupCommInfo.groupIndices;
                if (groupIndices) {
                  for (const groupIndex of groupIndices) {
                    if (groupIndex > value) {
                      hasValueGreaterThanValue = true;
                      break;
                    }
                  }
                }
                if (hasValueGreaterThanValue) {
                  groupIndices = [];
                }
              }
              ;
              settings.numberOfGroupsComm = value;
              await plugin.saveSettings();
            } else {
              slider.setValue(numberOfGroupsComm);
            }
          }, 700);
        } else {
          clearTimeout(saveSettingsTimeout);
          settings.numberOfGroupsComm = value;
          await plugin.saveSettings();
        }
      });
    });
    new import_obsidian10.Setting(containerEl).setName("Show hotkeys line reminder").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showHotKeys).onChange((value) => {
        this.plugin.settings.showHotKeys = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(containerEl).setName("Keep dropdowns last value").setDesc("If enabled, dropdowns will be kept in last value when opening the modal").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.keepDropDownValues).onChange((value) => {
        this.plugin.settings.keepDropDownValues = value;
        this.plugin.saveSettings();
      });
    });
    const fragment = new DocumentFragment();
    fragment.createDiv({}, (div) => {
      div.innerHTML = `
						Enter a new folder path or search it. <br>If you provide a non existing folder path, it will be created when adding a new note.<br> If you delete the file in, you lose your notes`;
    });
    new import_obsidian10.Setting(containerEl).setName("Community plugins notes folder").setDesc(fragment).addSearch((component) => {
      const inputEl = component.inputEl;
      new FolderSuggest(this.app, inputEl);
      component.setValue(this.plugin.settings.commPluginsNotesFolder);
      inputEl.onblur = async () => {
        this.plugin.settings.commPluginsNotesFolder = component.getValue();
        await this.plugin.saveSettings();
      };
    });
  }
};

// src/main.ts
var QuickPluginSwitcher = class extends import_obsidian11.Plugin {
  constructor() {
    super(...arguments);
    this.lengthAll = 0;
    this.lengthDisabled = 0;
    this.lengthEnabled = 0;
    this.reset = false;
    this.exeAfterDelay = async (func) => {
      const currentTime = Date.now();
      if (currentTime - this.settings.lastFetchExe >= 12e4) {
        const ret = await func();
        if (ret === true) {
          this.settings.lastFetchExe = currentTime;
          await this.saveSettings();
        } else {
          Console.log("community plugins udpate failed, check your connexion");
        }
      } else {
        Console.log(
          "fetched less than 2 min, community plugins not updated"
        );
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.app.workspace.onLayoutReady(async () => {
      this.settings.savedVersion = this.manifest.version;
      const installed = this.settings.installed || {};
      const manifests = this.app.plugins.manifests || {};
      let stillInstalled = [];
      for (const pluginId in installed) {
        if (pluginId in manifests)
          stillInstalled.push(pluginId);
        else {
          delete installed[pluginId];
        }
      }
      const { wrapper1, wrapper2 } = this.wrapDisableEnablePluginAndSave(
        stillInstalled,
        async () => {
          await this.saveSettings();
        }
      );
      this.register(wrapper1);
      this.register(wrapper2);
      for (const id of stillInstalled) {
        if (isEnabled(this, id) !== installed[id].enabled && !installed[id].delayed && !(installed[id].target === 1 /* Mobile */ || installed[id].target === 0 /* Desktop */)) {
          installed[id].enabled = !installed[id].enabled;
        }
      }
      await this.saveSettings();
      for (const id of stillInstalled) {
        const isPlatformDep = installed[id].target === 1 /* Mobile */ || installed[id].target === 0 /* Desktop */;
        const platformOff = installed[id].target === 1 /* Mobile */ && import_obsidian11.Platform.isDesktop || installed[id].target === 0 /* Desktop */ && import_obsidian11.Platform.isMobile;
        if (installed[id].commandified) {
          await addCommandToPlugin(this, installed[id]);
        }
        if ((installed[id].delayed || isPlatformDep) && installed[id].enabled) {
          if (platformOff) {
            await this.app.plugins.disablePlugin(id);
          } else {
            if (installed[id].delayed) {
              const time = installed[id].time * 1e3 || 0;
              setTimeout(
                async () => await this.app.plugins.enablePlugin(id),
                time
              );
            } else {
              await this.app.plugins.enablePlugin(id);
            }
          }
        }
        installed[id].toUpdate = false;
      }
    });
    this.addSettingTab(new QPSSettingTab(this.app, this));
    this.addRibbonIcon(
      "toggle-right",
      "Quick Plugin Switcher",
      async (evt) => {
        if (!this.settings.keepDropDownValues) {
          this.settings.filters = Filters.all;
          this.settings.filtersComm = CommFilters.all;
        }
        await this.installedUpdate();
        new QPSModal(this.app, this).open();
        focusSearchInput(10);
        await this.exeAfterDelay(this.pluginsCommInfo.bind(this));
        setTimeout(async () => {
          await updateNotes(this);
        }, 700);
      }
    );
    this.addCommand({
      id: "quick-plugin-switcher-modal",
      name: "open modal",
      callback: async () => {
        if (!this.settings.keepDropDownValues) {
          this.settings.filters = Filters.all;
          this.settings.filtersComm = CommFilters.all;
        }
        await this.installedUpdate();
        new QPSModal(this.app, this).open();
        focusSearchInput(10);
        await this.exeAfterDelay(this.pluginsCommInfo.bind(this));
        setTimeout(async () => {
          await updateNotes(this);
        }, 700);
      }
    });
  }
  wrapDisableEnablePluginAndSave(stillInstalled, cb2) {
    const installed = this.settings.installed || {};
    const wrapper1 = around(this.app.plugins, {
      disablePluginAndSave(oldMethod) {
        return async function(pluginId) {
          if (stillInstalled.length) {
            const id = stillInstalled.find(
              (id2) => id2 === pluginId && !isEnabled(this, pluginId)
            );
            if (id && (installed[id].delayed && installed[id].time > 0 || (installed[id].target === 1 /* Mobile */ || installed[id].target === 0 /* Desktop */))) {
              installed[id].enabled = false;
              cb2();
            }
          }
          return oldMethod.call(this, pluginId);
        };
      }
    });
    const wrapper2 = around(this.app.plugins, {
      enablePluginAndSave(oldMethod) {
        return async function(pluginId) {
          let altReturn = false;
          if (stillInstalled.length) {
            const id = stillInstalled.find(
              (id2) => id2 === pluginId && isEnabled(this, id2)
            );
            if (id && installed[id].delayed && installed[id].time > 0) {
              installed[id].enabled = true;
              altReturn = true;
              cb2();
            }
          }
          if (altReturn)
            return this.app.plugins.enablePlugin.call(
              this,
              pluginId
            );
          return oldMethod.call(this, pluginId);
        };
      }
    });
    return { wrapper1, wrapper2 };
  }
  async installedUpdate() {
    const installed = this.settings.installed || {};
    const manifests = this.app.plugins.manifests || {};
    let stillInstalled = [];
    for (const id in installed) {
      if (id in manifests)
        stillInstalled.push(id);
      else {
        delete installed[id];
      }
    }
    for (const key in manifests) {
      const inListId = stillInstalled.find(
        (id) => id === key
      );
      if (inListId) {
        if (isEnabled(this, key) !== installed[key].enabled) {
          if (!(installed[key].delayed || (installed[key].target === 1 /* Mobile */ || installed[key].target === 0 /* Desktop */))) {
            installed[key].enabled = !installed[key].enabled;
          } else if (installed[key].delayed || (installed[key].target === 1 /* Mobile */ || installed[key].target === 0 /* Desktop */)) {
            if (isEnabled(this, key)) {
              installed[key].enabled = true;
              await this.app.plugins.disablePluginAndSave(
                key
              );
              await this.app.plugins.enablePlugin(
                key
              );
            }
          }
        }
        installed[key] = {
          ...installed[key],
          ...manifests[key]
        };
      } else {
        const complement = {
          enabled: isEnabled(this, key) || false,
          switched: 0,
          groupInfo: {
            hidden: false,
            groupIndices: [],
            groupWasEnabled: false
          },
          delayed: false,
          time: 0
        };
        installed[key] = {
          ...manifests[key],
          ...complement
        };
      }
    }
    this.getLength();
    await this.saveSettings();
  }
  getLength() {
    const installed = this.settings.installed;
    this.lengthAll = Object.keys(installed).length;
    this.lengthEnabled = 0;
    this.lengthDisabled = 0;
    for (const key in installed) {
      if (installed[key].enabled) {
        this.lengthEnabled++;
      } else {
        this.lengthDisabled++;
      }
    }
  }
  async pluginsCommInfo() {
    Console.log("fetching'''''''''''''''''''''''''");
    let plugins, stats;
    try {
      plugins = await fetchData(COMMPLUGINS);
      stats = await fetchData(COMMPLUGINSTATS);
    } catch (e) {
      return false;
    }
    if (plugins && stats) {
      const { commPlugins, pluginStats } = this.settings;
      for (const plugin of plugins) {
        let updateStats;
        if (plugin.id in stats) {
          updateStats = {
            downloads: stats[plugin.id].downloads || 0,
            updated: stats[plugin.id].updated || 0
          };
        } else {
          updateStats = {
            downloads: 0,
            updated: 0
          };
        }
        if (plugin.id in commPlugins) {
          commPlugins[plugin.id] = { ...commPlugins[plugin.id], ...plugin, ...updateStats };
        } else {
          const complement = {
            groupCommInfo: {
              hidden: false,
              groupIndices: []
            },
            hasNote: false,
            ...updateStats
          };
          commPlugins[plugin.id] = { ...plugin, ...complement };
        }
      }
      this.settings.pluginStats = { ...this.settings.pluginStats, ...stats };
      this.settings.plugins = plugins.map((plugin) => plugin.id);
      await this.saveSettings();
      Console.log("fetched");
      return true;
    }
    return false;
  }
  async loadSettings() {
    this.settings = { ...DEFAULT_SETTINGS, ...await this.loadData() };
  }
  async onExternalSettingsChange() {
    await this.loadSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
